#include "vtkPNGReader.h"
#include "vtkImageFlip.h"

#ifdef VTK_USE_ANSI_STDLIB
#define VTK_IOS_NOCREATE 
#else
#define VTK_IOS_NOCREATE | ios::nocreate
#endif


int main(int argc, char **argv)
{
  if ( argc < 3 )
    {
    cerr << "Usage: " << argv[0] << " image.png image.h" << endl;
    return 1;
    }

  ifstream in(argv[1], ios::in VTK_IOS_NOCREATE );
  if ( in.fail() )
    {
    cerr << "Cannot open: " << argv[1] << " for reading" << endl;
    return 2;
    }
  ofstream out(argv[2], ios::out );
  if ( out.fail() )
    {
    cerr << "Cannot open: " << argv[1] << " for writing" << endl;
    return 3;
    }
  
  vtkPNGReader *pr = vtkPNGReader::New();
  pr->SetFileName( argv[1] );
  pr->Update();

  if (pr->GetOutput()->GetNumberOfScalarComponents() != 3 &&
      pr->GetOutput()->GetNumberOfScalarComponents() != 4)
    {
    cerr << "Can only convert RGB or RGBA images" << endl;
    pr->Delete();
    return 4;
    }

  vtkImageFlip *flip = vtkImageFlip::New();
  flip->SetInput( pr->GetOutput() );
  flip->SetFilteredAxis( 1 );
  flip->Update();

  char buffer[1024];
  int *dim = flip->GetOutput()->GetDimensions();
  int width = dim[0];
  int height = dim[1];
  int pixelsize = flip->GetOutput()->GetNumberOfScalarComponents();

  unsigned long length = width * height;
  unsigned char *image = new unsigned char[ length * pixelsize ];
  memcpy(image, flip->GetOutput()->GetScalarPointer(), length * pixelsize);
  strcpy(buffer, argv[2]);
  buffer[ strlen(buffer)-2 ] = 0;

  out << "/* " << endl
      << " * This file is generated by ImageConvert from image:" << endl
      << " *    " << argv[1] << endl
      << " */" << endl;
  
  out << "#define image_" << buffer << "_width " << width << endl
      << "#define image_" << buffer << "_height " << height << endl
      << "#define image_" << buffer << "_pixelsize " << pixelsize << endl
      << "static unsigned char image_" << buffer << "[] = {" << endl
      << "  ";

  unsigned long cc;
  for ( cc = 0; cc<length; cc++ )
    {    
    if ( cc % (width) == 0 )
      {
      out << endl << "/* " << (cc / (width * pixelsize)) << " */ ";
      }
    
    if (pixelsize == 4 && (unsigned int)image[cc * pixelsize + 3] == 0)
      {
      out << "0, 0, 0, 0";
      }
    else
      {
      out << (unsigned int)image[cc * pixelsize] << ", "
          << (unsigned int)image[cc * pixelsize + 1] << ", "
          << (unsigned int)image[cc * pixelsize + 2];
      if (pixelsize == 4)
        {
        out << ", " << (unsigned int)image[cc * pixelsize + 3];
        }
      }

    if ( cc != (length)-1 )
      {
      out << ", ";
      }
    if ( cc % pixelsize == 11 )
      {
      out << endl << "  ";
      }
    }
  out << "};" << endl;
  out.close();

  pr->Delete();
  flip->Delete();
  return 0;
}
