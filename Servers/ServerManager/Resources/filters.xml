<ServerManagerConfiguration>
  <ProxyGroup name="filters">

   <SourceProxy name="ImageShrink" class="vtkImageShrink3D" label="Image Shrink">
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Image Shrink filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="ShrinkFactors" 
        command="SetShrinkFactors" 
        number_of_elements="3"
        animateable="1"
        default_values="1 1 1" > 
       <IntRangeDomain name="range" min="1" max="100"/>
       <Documentation>
         Set the amount by which to shrink along each axis.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Averaging" 
        command="SetAveraging" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to use an average of neighborhood scalar values as the output scalar value. If off, only subsampling will be performed.
       </Documentation>
     </IntVectorProperty>
   <!-- End ImageShrink -->
   </SourceProxy>

   <SourceProxy name="SurfaceVectors" class="vtkSurfaceVectors" label="Surface Vectors">
     <Documentation
          long_help="This filter constrains vectors to lie on a surface."
          short_help="This filter constrains vectors o lie on a surface.">
The surface vectors filter is used for 2D data sets.  It constrains vectors to lie in a surface by removing components of the vectors normal to the local surface.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             Set the input to the Surface Vectors filter.
           </Documentation>
     </InputProperty>

     <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         animateable="0"> 
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              Select the input vector array to process.
            </Documentation>
     </StringVectorProperty> 

     <IntVectorProperty 
        name="ConstraintMode" 
        command="SetConstraintMode" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Parallel"/>
         <Entry value="1" text="Perpendicular"/>
         <Entry value="2" text="PerpendicularScale"/>
       </EnumerationDomain>
       <Documentation>
         Specify whether the vectors will be parallel or perpendicular to the surface.
       </Documentation>
     </IntVectorProperty>

   <!-- End SurfaceVectors -->
   </SourceProxy>

   <SourceProxy name="IntegrateAttributes" class="vtkIntegrateAttributes" 
     label="Integrate Attributes">
     <Documentation 
        long_help="This filter integrates cell and point attributes.  Use selects whether the integration is over 1D lines, 2D surfaces or 3D volumes.  Cells not of the selected dimension are ignored."
        short_help="Integrates over lines, surfaces or vectors.">
Integrates point and cell data over lines and surfaces.  It also computes length of lines, area of surface or volume.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Integrate Attributes filter.
           </Documentation>
      </InputProperty>
   <Hints>
     <Visibility replace_input="0" />
   </Hints>
   <!-- End IntegrateAttributes -->
   </SourceProxy>

   <SourceProxy name="IntegrateFlowThroughSurface" class="vtkIntegrateFlowThroughSurface" label="Surface Flow">
     <Documentation
        long_help="This filter integrates flow through a surface."
        short_help="This filter integrates flow through a surface.">
The flow integration fitler  integrates the dot product of a point flow vector field and surface normal.  It computes the net flow across the 2D surface..
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             Set the input to the Surface Flow filter.
           </Documentation>
      </InputProperty>

      <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              Select the input vectors to process.
            </Documentation>
      </StringVectorProperty> 

   <!-- End IntegrateFlowThroughSurface -->
   </SourceProxy>

   <SourceProxy name="AllToN" class="vtkAllToNRedistributePolyData"
      label="All to N">
      <Documentation
         long_help="Redistribute data to a subset of available processes."
         short_help="Repartition data filter.">
The All to N filter is available when ParaView is run in parallel. It redistributes the data so that it is located on the number of processes specified in the Number of Processes entry box. It also does load-balancing of the data among these processes. This filter operates on polygonal data and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the All to N filter.
           </Documentation>
      </InputProperty>

      <IntVectorProperty 
         name="NumberOfProcesses" 
         command="SetNumberOfProcesses" 
         number_of_elements="1"
         default_values="1"
         label="Number of Processes"> 
         <Documentation>
           Set the number of processes across which to split the input data.
         </Documentation>
      </IntVectorProperty>         
   <!-- End AllToN -->
   </SourceProxy>

   <SourceProxy name="Balance" class="vtkBalancedRedistributePolyData">
      <Documentation
         long_help="Balance data among available processes."
         short_help="Load balance filter.">
The Balance filter is available when ParaView is run in parallel. It does load-balancing so that all processes have the same number of cells. It operates on polygonal data sets and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Balance filter.
           </Documentation>
      </InputProperty>
   <!-- End Balance -->
   </SourceProxy>

   <SourceProxy name="AppendAttributes" class="vtkMergeArrays"
    label="Append Attributes">
      <Documentation
         long_help="Copies geometry from first input.  Puts all of the arrays into the output."
         short_help="Puts all input arrays into the single output.">
The Append Attributes filter takes multiple input data sets with the same geometry and merges their point and cell attributes to produce a single output containing all the point and cell attributes of the inputs. Any inputs without the same number of points and cells as the first input are ignored. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Append Attributes filter.
           </Documentation>
      </InputProperty>
         
   <!-- End AppendAttributes -->
   </SourceProxy>

   <SourceProxy name="AppendPolyData" class="vtkAppendPolyData"
      label="Append Geometry">
      <Documentation
         long_help="Takes an input of multiple poly data parts and output has only one part."
         short_help="Append multiple parts into one.">
The Append Geometry filter operates on multiple polygonal data sets. The data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets. It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Append Geometry filter.
           </Documentation>
      </InputProperty>
   <!-- End AppendPolyData -->
   </SourceProxy>

   <SourceProxy name="Append" class="vtkAppendFilter" label="Append Datasets">
      <Documentation
         long_help="Takes an input of multiple datasets and output has only one unstructured grid."
         short_help="Append multiple datasets into one.">
The Append Datasets filter operates on multiple data sets of any type (polygonal, structured, etc.). It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Append Datasets filter.
           </Documentation>
      </InputProperty>
   <!-- End AppendDataSet -->
   </SourceProxy>

   <SourceProxy name="CellCenters" class="vtkCellCenters" label="Cell Centers">
     <Documentation
        long_help="Create a point (no geometry) at the center of each input cell."
        short_help="Convert cells to vertices.">
The Cell Centers filter places a point at the center of each cell in the input data set. The center computed is the parametric center of the cell, not necessarily the geometric or bounding box center. The cell attributes of the input will be associated with these newly created points of the output. The Input menu allows the user to select the data set to which this filter will be applied. If the Generate vertices option is checked, then vertex cells will also be created for each point in the output. This is useful because vertex cells are rendered, but points are not. The points themselves could be used for placing glyphs (using the Glyph filter). The Cell Centers filter takes any type of data set as input and produces a polygonal data set as output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Cell Centers filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="VertexCells" 
        command="SetVertexCells" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Specify whether to generate vertex cells as the topography of the output.
       </Documentation>
     </IntVectorProperty>
   <!-- End CellCenters -->
   </SourceProxy>

   <SourceProxy name="CellDataToPointData" class="vtkPCellDataToPointData"
     label="Cell Data to Point Data">
     <Documentation
        long_help="Create point attributes by averaging cell attributes."
        short_help="Convert cell data to point data.">
The Cell Data to Point Data filter averages the values of the cell attributes of the cells surrounding a point to compute point attributes. The Input menu allows the user to select the data set to which this filter will be applied. If the Pass cell data option is checked, then the input cell attributes will also be copied to the cell attributes of the output; otherwise the output will only have point attributes. The Cell Data to Point Data filter operates on any type of data set, and the output data set is of the same type as the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="cell"/>
          <Documentation>
            Set the input to the Cell Data to Point Data filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="PassCellData" 
        command="SetPassCellData" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Control whether the input cell data will be passed to the output. If on, then the input cell data is passed through to the output; otherwise, only generated point data is placed into the output.
       </Documentation>
     </IntVectorProperty>
   <!-- End CellDataToPointData -->
   </SourceProxy>

   <SourceProxy name="CleanPolyData" class="vtkCleanPolyData"
     label="Clean">
     <Documentation
        long_help="Merge coincident points if they do not meet a feature edge critera."
        short_help="Merge coincident points.">
The Clean filter takes polygonal data as input and generates polygonal data as output. This filter can merge duplicate points, remove unused points, and transform degenerate cells into their appropriate forms (e.g., a triangle is converted into a line if two of its points are merged). The Input menu allows the user to select the data set to which this filter will be applied. If the Point merging option is on, then points will be merged if they are within the specified Tolerance or Absolute tolerance, depending on whether the Tolerance is absolute box is checked. (Tolerance is specified as a fraction of the length of the diagonal of the bounding box of the data set; Absolute tolerance is specified in the spatial units of the input data set.)
The transforming of degenerate cells into their appropriate forms is controlled by three check boxes on the user interface: Convert lines to points, Convert polys to lines, and Convert strips to polys. If any of these is unchecked, then degenerate cells of that type will not be converted to another type of cell.
If the Piece invariant option is checked, the whole data set will be processed at once so that cleaning this data set always produces the same results. If the box is unchecked, the data set can be processed one piece at a time, so it is not necessary for the entire data set to fit into memory, but the results are not guaranteed to be the same as they would be if the Piece invariant option was on.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Clean filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Specify whether the results must be the same regardless of whether ParaView is run in parallel or in a single process. Turn this option on to remove seams when running in parallel.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Tolerance"
        command="SetTolerance"
        number_of_elements="1"
        animateable="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range" min="0" max="1" />
       <Documentation>
         Set the tolerance (for whether to combine nearby points) in terms of fraction of bounding box length.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="AbsoluteTolerance"
        command="SetAbsoluteTolerance"
        number_of_elements="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range" min="0"/>
       <Documentation>
         Set the tolerance (for whether to combine nearby points) in absolute terms.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="ToleranceIsAbsolute" 
        command="SetToleranceIsAbsolute" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Determine whether to use absolute or relative (a percentage of the bounding box) tolerance.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ConvertLinesToPoints" 
        command="SetConvertLinesToPoints" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn on/off conversion of degenerate lines to points.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ConvertPolysToLines" 
        command="SetConvertPolysToLines" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn on/off conversion of degenerate polys to lines.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ConvertStripsToPolys" 
        command="SetConvertStripsToPolys" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn on/off conversion of degenerate strips to polys.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="PointMerging" 
        command="SetPointMerging" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to perform point-merging.
       </Documentation>
     </IntVectorProperty>
   <!-- End CleanPolyData -->
   </SourceProxy>

   <SourceProxy name="CleanUnstructuredGrid" class="vtkCleanUnstructuredGrid"
      label="Clean to Grid">
      <Documentation
         long_help="This filter merges points and converts the data set to unstructured grid."
         short_help="Merge points.">
The Clean to Grid filter merges points that are within a tolerance of 1/100,000 of the length of the diagonal of the bounding box of the data set. It also converts the data set to an unstructured grid. You may wish to do this if you want to apply a filter to your data set that is available for unstructured grids but not for the initial type of your data set (e.g., applying warp vector to volumetric data). The Input menu allows the user to select the data set to which this filter will be applied. The Clean to Grid filter operates on any type of data set.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Clean to Grid filter.
           </Documentation>
      </InputProperty>
   <!-- End CleanUnstructuredGrid -->
   </SourceProxy>

   <SourceProxy name="Delaunay2D" class="vtkDelaunay2D" label="Delaunay 2D">
      <Documentation
         long_help="Create 2D Delaunay triangulation of input points. 
It expects a vtkPointSet as input and produces vtkPolyData as output. 
The points are expected to be in a mostly planar distribution."
         short_help="Create 2D Delaunay triangulation of input points.">
Delaunay2D is a filter that constructs a 2D Delaunay triangulation from 
a list of input points. These points may be represented by any dataset 
of type vtkPointSet and subclasses. The output of the filter is a 
polygonal dataset containing a triangle mesh.

The 2D Delaunay triangulation is defined as the triangulation that 
satisfies the Delaunay criterion for n-dimensional simplexes (in this 
case n=2 and the simplexes are triangles). This criterion states that a 
circumsphere of each simplex in a triangulation contains only the n+1 
defining points of the simplex. (See "The Visualization Toolkit" text 
for more information.) In two dimensions, this translates into an 
optimal triangulation. That is, the maximum interior angle of any 
triangle is less than or equal to that of any possible triangulation.

Delaunay triangulations are used to build topological structures from 
unorganized (or unstructured) points. The input to this filter is a list 
of points specified in 3D, even though the triangulation is 2D. Thus the 
triangulation is constructed in the x-y plane, and the z coordinate is 
ignored (although carried through to the output). You can use the option
ProjectionPlaneMode in order to compute the best-fitting plane to the
set of points, project the points and that plane and then perform the
triangulation using their projected positions and then use it as the 
plane in which the triangulation is performed.

The Delaunay triangulation can be numerically sensitive in some cases. 
To prevent problems, try to avoid injecting points that will result in 
triangles with bad aspect ratios (1000:1 or greater). In practice this 
means inserting points that are "widely dispersed", and enables smooth 
transition of triangle sizes throughout the mesh. (You may even want to 
add extra points to create a better point distribution.) If numerical 
problems are present, you will see a warning message to this effect at 
the end of the triangulation process.

Warning:
     Points arranged on a regular lattice (termed degenerate cases) can 
be triangulated in more than one way (at least according to the Delaunay 
criterion). The choice of triangulation (as implemented by this 
algorithm) depends on the order of the input points. The first three 
points will form a triangle; other degenerate points will not break this 
triangle.

     Points that are coincident (or nearly so) may be discarded by the 
algorithm. This is because the Delaunay triangulation requires unique 
input points. The output of the Delaunay triangulation is supposedly a 
convex hull. In certain cases this implementation may not generate the 
convex hull.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Delaunay 2D filter.
           </Documentation>
      </InputProperty>
      <IntVectorProperty 
        name="ProjectionPlaneMode" 
        command="SetProjectionPlaneMode" 
        number_of_elements="1"
        default_values="0"> 
       <EnumerationDomain name="enum">
         <Entry value="0" text="XY Plane"/>
<!--         <Entry value="1" text="Perpendicular"/> -->
         <Entry value="2" text="Best-Fitting Plane"/>
       </EnumerationDomain>
       <Documentation>
         Set what type of projection plane to use in performing the triangulation.
       </Documentation>
     </IntVectorProperty>
     <DoubleVectorProperty name="Alpha"
       command="SetAlpha"
       number_of_elements="1"
       animateable="1"
       default_values="0.0">
       <DoubleRangeDomain name="range" min="0"/>
       <Documentation>
         Specify alpha (or distance) value to control the output of this filter. For a non-zero alpha value, only edges or triangles contained within a sphere centered at mesh vertices will be output. Otherwise, only triangles will be output.
       </Documentation>
     </DoubleVectorProperty>
     <DoubleVectorProperty name="Tolerance"
       command="SetTolerance"
       number_of_elements="1"
       animateable="1"
       default_values="0.00001">
       <DoubleRangeDomain name="range" min="0" max="1.0" />
       <Documentation>
         Specify a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.
       </Documentation>
     </DoubleVectorProperty>
     <DoubleVectorProperty name="Offset"
       command="SetOffset"
       number_of_elements="1"
       animateable="1"
       default_values="1.0">
       <DoubleRangeDomain name="range" min="0.75"/>
       <Documentation>
         Specify a multiplier to control the size of the initial, bounding Delaunay triangulation.
       </Documentation>
     </DoubleVectorProperty>
     <IntVectorProperty name="BoundingTriangulation"
       command="SetBoundingTriangulation"
       number_of_elements="1"
       animateable="1"
       default_values="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         If checked, bounding triangulation points (and associated triangles) are included in the output. (These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.)
       </Documentation>
     </IntVectorProperty>
   </SourceProxy>

   <SourceProxy name="PVConnectivityFilter" class="vtkPVConnectivityFilter"
      label="Connectivity">
      <Documentation
          long_help="Mark connected components with integer point attribute array."
          short_help="Find connected components.">
The Connectivity filter assigns a region id to connected components of the input data set. (The region id is assigned as a point scalar value.) The Input menu allows the user to select the data set to which this filter will be applied. This filter takes any data set type as input and produces unstructured grid output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Connectivity filter.
           </Documentation>
      </InputProperty>
   <!-- End PVConnectivityFilter -->
   </SourceProxy>

   <SourceProxy name="ImageClip" class="vtkImageClip" label="Crop">
    <Documentation
       long_help="Efficiently extract an area/volume of interest from a 2-d image or 3-d volume."
       short_help="Extract a volume of interest.">
The Crop filter extracts an area/volume of interest from a 2D image or a 3D volume by allowing the user to specify the minimum and maximum extents of each dimension of the data. The Input menu allows the user to select the data set to which this filter will be applied. Both the input and output of this filter are uniform rectilinear data.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Crop filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="OutputWholeExtent" 
        command="SetOutputWholeExtent" 
        number_of_elements="6"
        default_values="0 0 0 0 0 0"> 
       <ExtentDomain name="extent">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ExtentDomain>
       <Documentation>
         Set the minimum and maximum extents in each dimension of the output.
       </Documentation>
     </IntVectorProperty>
    <Hints>
      <Visibility replace_input="0" />
    </Hints>
   <!-- End ImageClip -->
   </SourceProxy>

   <SourceProxy name="Curvatures" class="vtkCurvatures" label="Curvature">
    <Documentation
       long_help="This filter will compute the gaussian or mean curvature of the mesh at each point."
       short_help="Compute the curvature at each point.">
The Curvature filter computes the curvature at each point in a polygonal data set. This filter supports both Gaussian and mean curvatures; the type can be selected from the Curvature type menu button. The Input menu allows the user to select the data set to which this filter will be applied. If the Invert mean curvature option is checked, the mean curvature calculation will be inverted. This is useful for meshes with inward-pointing normals.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Curvature filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="InvertMeanCurvature" 
        command="SetInvertMeanCurvature" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn on this option to invert the mean curvature calculation for meshes with inward pointing normals.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="CurvatureType" 
        command="SetCurvatureType" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Gaussian"/>
         <Entry value="1" text="Mean"/>
       </EnumerationDomain>
       <Documentation>
         Select the type of curvature to compute.
       </Documentation>
     </IntVectorProperty>
   <!-- End Curvatures -->
   </SourceProxy>

   <SourceProxy name="DecimatePro" class="vtkDecimatePro" label="Decimate">
     <Documentation
        long_help="Simplify a polygonal model using an adaptive edge collapse algorithm.  This filter works with triangles only."
        short_help="Reduce the number of triangles in a model.">
The Decimate filter reduces the number of triangles in a polygonal data set. Because this filter only operates on triangles, first run the Triangulate filter on a data set that contains polygons other than triangles. The Input menu allows the user to select the data set to which this filter will be applied. The Reduction target slider specifies the desired reduction in the total number of polygons (e.g., if the Reduction target value is 0.9, the Decimate filter will attempt to produce an output data set that is 10% the size of the input.) If the Preserve topology option is on, decimation will not split the data set or produce holes, but it may keep the filter from reaching the reduction target. The Feature angle slider value is used in determining where the data set may be split. If the angle between two adjacent triangles is >= the Feature angle value, then their boundary is considered a feature edge where the data set can be split. If the Boundary deletable option is on, then vertices on the boundary of the data set can be removed. Turning this option off preserves the boundary of the data set, but it may cause the filter not to reach its reduction target.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Decimate filter.
           </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="TargetReduction"
         command="SetTargetReduction"
         number_of_elements="1"
         animateable="1"
         default_values="0.9" >
        <DoubleRangeDomain name="range" min="0" max="1" />
        <Documentation>
          Set the desired reduction as a percentage of the total number of triangles.
        </Documentation>
      </DoubleVectorProperty>

     <IntVectorProperty 
        name="PreserveTopology" 
        command="SetPreserveTopology" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If off, better reduction can occur, but model may break up. If on, mesh splitting and hole elimination will not occur.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="FeatureAngle"
        command="SetFeatureAngle"
        number_of_elements="1"
        default_values="15.0" >
       <DoubleRangeDomain name="range" min="0" max="180" />
       <Documentation>
         This angle is used to define a feature edge, an edge along which the topology can be split. If the surface normal between two adjacent triangles is as least as large as this Feature Angle, a feature edge exists.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="BoundaryVertexDeletion" 
        command="SetBoundaryVertexDeletion" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If off, the Decimate filter will not remove points on the boundary of the dataset.
       </Documentation>
     </IntVectorProperty>
   <!-- End DecimatePro -->
   </SourceProxy>

   <SourceProxy name="D3" class="vtkDistributedDataFilter" label="D3">
    <Documentation
       long_help="Repartition a data set into load-balanced spatially convex regions.  Create ghost cells if requested."
       short_help="Repartition a data set.">
The D3 filter is available when ParaView is run in parallel. It operates on any type of data set to evenly divide it across the processors into spatially contiguous regions. The Boundary Cells menu determines how cells that lie on processor boundaries are handled. The Assign cells uniquely option assigns each boundary cell to exactly one process, which is useful for isosurfacing. Selecting Duplicate cells causes the cells on the boundaries to be copied to each process that shares that boundary. The Divide cells option breaks cells across process boundary lines so that pieces of the cell lie in different processes. This option is useful for volume rendering. The output of this filter is of type unstructured grid.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the D3 filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="BoundaryMode" 
        command="SetBoundaryMode" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Assign cells uniquely"/>
         <Entry value="1" text="Duplicate cells"/>
         <Entry value="2" text="Divide cells"/>
       </EnumerationDomain>
       <Documentation>
         Select how to handle boundary cells. Isosurfacing works well when cells are uniquely assigned to processes. Dividing cells along processor boundaries is useful for volume rendering.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseMinimalMemory" 
        command="SetUseMinimalMemory" 
        number_of_elements="1"
        default_values="0"
        label="Minimal Memory"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Force communication routines to use minimal memory, which is slower.
       </Documentation>
     </IntVectorProperty>
   <!-- End D3 -->
   </SourceProxy>

   <SourceProxy name="ElevationFilter" class="vtkElevationFilter" label="Elevation">
     <Documentation
        long_help="Create point attribute array by projecting points onto an elevation vector."
        short_help="Create a point array representing elevation.">
The Elevation filter generates point scalar values for an input data set along a specified direction vector. The Input menu allows the user to select the data set to which this filter will be applied. Use the Scalar range entry boxes to specify the minimum and maximum scalar value to be generated. The Low Point and High Point define a line onto which each point of the data set is projected. The minimum scalar value is associated with the Low Point, and the maximum scalar value is associated with the High Point. The scalar value for each point in the data set is determined by the location along the line to which that point projects.
The line can be specified interactively using the 3D line widget. See section 7.4 for more information about this widget.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Elevation filter.
           </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="ScalarRange"
         command="SetScalarRange"
         number_of_elements="2"
         default_values="0 1" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          Specify range to map scalars into. Default is [0, 1].
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="LowPoint"
         label="Low Point"
         command="SetLowPoint"
         number_of_elements="3"
         animateable="1"
         default_values="0 0 0" >
         <BoundsDomain name="range" mode="normal" default_mode="min" >
           <RequiredProperties>
             <Property name="Input" function="Input" />
           </RequiredProperties>
         </BoundsDomain>
         <Documentation>
           Define one end of the line (small scalar values). Default is (0,0,0).
         </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="HighPoint"
         label="High Point"
         command="SetHighPoint"
         number_of_elements="3"
         animateable="1"
         default_values="0 0 1" >
         <BoundsDomain name="range" mode="normal" default_mode="max" >
           <RequiredProperties>
             <Property name="Input" function="Input" />
           </RequiredProperties>
         </BoundsDomain>
         <Documentation>
           Define other end of the line (large scalar values). Default is (0,0,1).
         </Documentation>
      </DoubleVectorProperty>

      <Hints>
        <PropertyGroup type="Line" label="Elevation Widget">
          <Property function="Point1WorldPosition" name="LowPoint" />
          <Property function="Point2WorldPosition" name="HighPoint" />
        </PropertyGroup>
      </Hints>
   <!-- End ElevationFilter -->
   </SourceProxy>

#if 1
   <SourceProxy name="CTHPart" class="vtkExtractCTHPart"
    label="Extract CTH Parts">
    <Documentation
       long_help="Create a surface from a CTH volume fraction."
       short_help="Extract a part from a CTH dataset.">
Extract CTH Parts is a specialized filter for visualizing the data from a CTH simulation. It first converts the selected cell-centered arrays to point-centered ones. It then contours each array at a value of 0.5. The user has the option of clipping the resulting surface(s) with a plane.
If the Show All option is on, all the cell-centered scalar (single-component) arrays will be displayed in the array selection box; otherwise only the ones with "Fraction" or "fraction" in the name will be shown. (This behavior is because by default the CTH volume fraction arrays should be listed.) Clicking on the name of a particular array selects it. To choose multiple contiguous array names, click the first one and press the Shift key while clicking the last name you wish to select. If the names are not contiguous, press the Ctrl key while selecting the names from the list. The selected arrays will be contoured.
If you wish to clip the contour surfaces with a plane, select On from the menu in the Clipping section on this Parameters tab. You can interactively position and orient the plane using the plane widget. (See section 7.4 for the details of using this widget or manually setting the plane's parameters.)
This filter only operates on unstructured data. It produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="cell" 
                            number_of_components="1"/>
          <Documentation>
            Set the input to the Extract CTH Parts filter.
          </Documentation>
     </InputProperty>

<!-- For the below property, you also need a way to say, "Don't clip. -->

     <ProxyProperty name="ClipPlane" command="SetClipPlane"
        label="Clip Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             Adjust the parameters of the plane to clip with.
           </Documentation>
     </ProxyProperty>

<!-- The GUI for the property below needs a way to select multiple arrays,
     not just a text box for entering an array name. -->

     <StringVectorProperty 
        name="AddVolumeArrayName"
        command="AddVolumeArrayName" 
        repeat_command="1"
        number_of_elements_per_command="1"
        number_of_elements="1"
        label="Volume Arrays">
        <Documentation>
          Select the volume fraction arrays for generating parts.
        </Documentation>
     </StringVectorProperty> 

     <DoubleVectorProperty
        name="VolumeFractionSurfaceValue"
        command="SetVolumeFractionSurfaceValue"
        number_of_elements="1"
        default_values="0.1"
        label="Volume Fraction Value">
       <DoubleRangeDomain name="range" min="0" max="1" />
       <Documentation>
         Set the volume fraction value for the surface. Should be between 0 and 1.
       </Documentation>
     </DoubleVectorProperty>
   <!-- End CTHPart -->
   </SourceProxy>
#endif

   <SourceProxy name="ExtractEdges" class="vtkExtractEdges"
      label="Extract Edges">
     <Documentation
        long_help="Extract edges of 2-d and 3-d cells as lines."
        short_help="Covert data to wireframe.">
The Extract Edges filter produces a wireframe version of the input data set by extracting all the edges of the data set's cells as lines. The Input menu allows the user to select the data set to which this filter will be applied. This filter operates on any type of data set and produces polygonal output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Extract Edges filter.
           </Documentation>
      </InputProperty>
   <!-- End ExtractEdges -->
   </SourceProxy>

   <SourceProxy name="DataSetSurfaceFilter" class="vtkDataSetSurfaceFilter"
      label="Extract Surface">
     <Documentation
        long_help="Extract a 2-d boundary surface using neighbor relations to eliminate internal faces."
        short_help="Extract 2-d boundary surface.">
The Extract Surface filter extracts the polygons forming the outer surface of the input data set. The Input menu allows the user to select the data set to which this filter will be applied. This filter operates on any type of data and produces polygonal data as output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Extract Surface filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn this option on to remove internal surface between processes. NOTE: Enabling this option might cause multiple executions of the data source because more information is needed to remove internal surfaces.
       </Documentation>
     </IntVectorProperty>
   <!-- End DataSetSurfaceFilter -->
   </SourceProxy>

   <SourceProxy name="Calculator" class="vtkArrayCalculator">
    <Documentation
       long_help="Compute new attribute arrays as function of existing arrays."
       short_help="Compute new attribute arrays.">
The Calculator filter computes new data arrays as functions of existing scalar or vector arrays. The Input menu allows the user to select the data set to which this filter will be applied. The Result Array Name entry box allows the user to specify the name of the array containing the results of the computation. The Attribute Mode menu selects whether to operate on and produce results that are point-centered or cell-centered. If point-centered arrays are used, the resulting array will also be point-centered. The same is true for cell-centered arrays. The Calculator interface operates similarly to a scientific calculator. In creating the function to evaluate, the standard order of operations applies.
Each of the calculator functions is described below. Unless otherwise noted, enclose the operand in parentheses using the ( and ) buttons.
Clear: Erase the current function (displayed in the read-only text box above the calculator buttons).
/: Divide one scalar by another. The operands for this function are not required to be enclosed in parentheses.
*: Multiply two scalars, or multiply a vector by a scalar (scalar multiple). The operands for this function are not required to be enclosed in parentheses.
-: Negate a scalar or vector (unary minus), or subtract one scalar or vector from another. The operands for this function are not required to be enclosed in parentheses.
+: Add two scalars or two vectors. The operands for this function are not required to be enclosed in parentheses.
sin: Compute the sine of a scalar.
cos: Compute the cosine of a scalar.
tan: Compute the tangent of a scalar.
asin: Compute the arcsine of a scalar.
acos: Compute the arccosine of a scalar.
atan: Compute the arctangent of a scalar.
sinh: Compute the hyperbolic sine of a scalar.
cosh: Compute the hyperbolic cosine of a scalar.
tanh: Compute the hyperbolic tangent of a scalar.
x^y: Raise one scalar to the power of another scalar. The operands for this function are not required to be enclosed in parentheses.
sqrt: Compute the square root of a scalar.
e^x: Raise e to the power of a scalar.
log: Compute the logarithm of a scalar.
ceil: Compute the ceiling of a scalar.
floor: Compute the floor of a scalar.
abs: Compute the absolute value of a scalar.
v1.v2: Compute the dot product of two vectors. The operands for this function are not required to be enclosed in parentheses.
mag: Compute the magnitude of a vector.
norm: Normalize a vector.
The operands are described below.
The digits 0 - 9 and the decimal point are used to enter constant scalar values.
iHat, jHat, and kHat are vector constants representing unit vectors in the X, Y, and Z directions, respectively.
The scalars menu lists the names of the scalar arrays and the components of the vector arrays of either the point-centered or cell-centered data. The vectors menu lists the names of the point-centered or cell-centered vector arrays. The function will be computed for each point (or cell) using the scalar or vector value of the array at that point (or cell).
The filter operates on any type of data set, but the input data set must have at least one scalar or vector array. The arrays can be either point-centered or cell-centered. The Calculator filter's output is of the same data set type as the input.
The Calculator filter is available on the Toolbar.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array"/>
          <Documentation>
            Set the input to the Calculator filter.
          </Documentation>
     </InputProperty>

     <Property
        name="RemoveAllVariables"
        command="RemoveAllVariables"
        immediate_update="1"
        label="Clear">
        <Documentation>
          Erase the current function from the calulator's function entry box.
        </Documentation>
     </Property>

     <StringVectorProperty 
        name="ResultArrayName" 
        command="SetResultArrayName" 
        number_of_elements="1"
        default_values="Result">
        <Documentation>
          Provide a name for the output array containing the result of this computation.
        </Documentation>
     </StringVectorProperty> 
     
     <StringVectorProperty 
        name="Function" 
        command="SetFunction" 
        number_of_elements="1">
        <Documentation>
          Enter the equation for the new array.
        </Documentation>
     </StringVectorProperty>
   
     <StringVectorProperty 
        name="AddScalarVariable" 
        command="AddScalarVariable" 
        clean_command="RemoveScalarVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="3"
        element_types="2 2 0"
        label="Scalar Variable">
        <Documentation>
          Add a new scalar variable to the current function for computing a new array.
        </Documentation>
     </StringVectorProperty>

     <StringVectorProperty 
        name="AddVectorVariable" 
        command="AddVectorVariable" 
        clean_command="RemoveVectorVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="5"
        element_types="2 2 0 0 0"
        label="Vector Variable">
        <Documentation>
          Add a new vector variable to the current function for computing a new array.
        </Documentation>
     </StringVectorProperty>
     
     <StringVectorProperty 
        name="AddCoordinateScalarVariable" 
        command="AddCoordinateScalarVariable" 
        clean_command="RemoveCoordinateScalarVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="2"
        element_types="2 0"
        label="Coordinate Scalar Variable">
        <Documentation>
          Add a new scalar variable to the current function for computing new point coordinates.
        </Documentation>
     </StringVectorProperty>

     <StringVectorProperty 
        name="AddCoordinateVectorVariable" 
        command="AddCoordinateVectorVariable" 
        clean_command="RemoveCoordinateVectorVariables"
        number_of_elements="0" 
        repeat_command="1"
        number_of_elements_per_command="4"
        element_types="2 0 0 0"
        label="Coordinate Vector Variable">
        <Documentation>
          Add a new vector variable to the current function for computing new point coordinates.
        </Documentation>
     </StringVectorProperty>

     <IntVectorProperty 
        name="CoordinateResults" 
        command="SetCoordinateResults" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to compute point coordinates or a new array.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="AttributeMode" 
        command="SetAttributeMode" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="1" text="point_data"/>
         <Entry value="2" text="cell_data"/>
       </EnumerationDomain>
       <Documentation>
         Select whether to perform the computation on point-centered or cell-centered data.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ReplaceInvalidValues" 
        command="SetReplaceInvalidValues" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to replace invalid values in the computation with a specific value.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="ReplacementValue"
        command="SetReplacementValue"
        number_of_elements="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Set the value with which to replace invalid values in the computation.
       </Documentation>
     </DoubleVectorProperty>
   <!-- End Calculator -->
   </SourceProxy>

   <SourceProxy name="FeatureEdges" class="vtkFeatureEdges"
    label="Feature Edges">
    <Documentation
       long_help="This filter will extract edges along sharp edges of surfaces or boundaries of surfaces."
       short_help="Extract edges that meet the feature critera.">
The Feature Edges filter extracts various subsets of edges from the input data set. Which edges are extracted depends on which check boxes are marked. The four types of edges are as follows.
Boundary edges: line cells or edges used by only one polygon
Feature edges: edges used by two polygons whose dihedral angle > the value from the Feature angle slider
Non-manifold edges: edges used by three or more polygons
Manifold edges: edges used by exactly two polygons
If the Coloring option is checked, then the extracted edges are assigned a scalar value based on the type of the edge. The Input menu allows the user to select the data set to which this filter will be applied.
This filter operates on polygonal data and produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Feature Edges filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="BoundaryEdges" 
        command="SetBoundaryEdges" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to extract boundary edges.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="FeatureEdges" 
        command="SetFeatureEdges" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to extract feature edges.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="NonManifoldEdges" 
        command="SetNonManifoldEdges" 
        number_of_elements="1"
        default_values="1"
        label="Non-Manifold Edges"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to extract non-manifold edges.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ManifoldEdges" 
        command="SetManifoldEdges" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to extract manifold edges.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Coloring" 
        command="SetColoring" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to create a "coloring" array to label the edges by type.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="FeatureAngle"
        command="SetFeatureAngle"
        number_of_elements="1"
        default_values="30.0" >
       <DoubleRangeDomain name="range" min="0" max="180" />
       <Documentation>
         This angle is used to define a feature edge. If the surface normal between two adjacent triangles is at least as large as this Feature Angle, a feature edge exists.
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End FeatureEdges -->
   </SourceProxy>

   <SourceProxy name="Gradient" class="vtkImageGradient" label="Gradient">
    <Documentation>
The Gradient filter computes the gradient vector at each point in an image or volume. The Input menu allows the user to select the data set to which this filter will be applied. The Scalars menu determines from which scalar array the gradient will be computed. The Dimensionality menu selects whether the gradient will be calculated in 2 or 3 dimensions. If only 2 dimensions are used, gradients are only computed in X and Y. This filter uses central differences to compute the gradients. The Gradient filter operates on uniform rectilinear (image) data and produces image data output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point" 
                            number_of_components="1"/>
          <Documentation>
            Set the input to the Gradient filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
          number_of_elements="5"
          element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             Select the array from which to compute the gradient.
           </Documentation>
     </StringVectorProperty>
     <IntVectorProperty 
        name="Dimensionality" 
        command="SetDimensionality" 
        number_of_elements="1"
        default_values="3" >
       <EnumerationDomain name="enum">
         <Entry value="2" text="Two"/>
         <Entry value="3" text="Three"/>
       </EnumerationDomain>
       <Documentation>
         Select whether to compute the gradient in two dimensions or in three.
       </Documentation>
     </IntVectorProperty>
   <!-- End Gradient -->
   </SourceProxy>

   <SourceProxy name="UnstructuredGradient" class="vtkGradientFilter"
     label="Gradient (Unstructured)">
     <Documentation>
The Gradient filter estimates the gradient vector at each point or cell.  The Input menu allows the user to select the data set to which this filter will be applied.  The Field and Scalars menus allow the user to select the scalar array from which to compute gradients.  The Scalars menu determines from which scalar array the gradient will be computed.  The Result Array Name box allows the user to specify the name of the output array holding the computed gradients.
     </Documentation>
     <InputProperty name="Input" command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkPointSet"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array" number_of_components="1">
         <RequiredProperties>
           <Property name="SelectInputScalars" function="FieldDataSelection"/>
         </RequiredProperties>
       </InputArrayDomain>
       <Documentation>
         Set the input to the Gradient (Unstructured) filter.
       </Documentation>
     </InputProperty>

     <StringVectorProperty name="SelectInputScalars"
                           command="SetInputArrayToProcess"
                           number_of_elements="5"
                           element_types="0 0 0 0 2"
                           label="Scalar Array">
       <ArrayListDomain name="array_list" attribute_type="Scalars">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <FieldDataDomain name="field_list">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </FieldDataDomain>
       <Documentation>
         Select the scalar array from which to compute the gradient.
       </Documentation>
     </StringVectorProperty>
     <StringVectorProperty name="ResultArrayName"
                           command="SetResultArrayName"
                           number_of_elements="1"
                           default_values="Gradients">
       <Documentation>
         Provide a name for the output array containing the gradient vectors.
       </Documentation>
     </StringVectorProperty>
   <!-- End UnstructuredGradient -->
   </SourceProxy>

   <SourceProxy name="GradientMagnitude" class="vtkImageGradientMagnitude"
      label="Gradient Magnitude">
     <Documentation>
The Gradient Magnitude filter computes the magnitude of the gradient vector at each point in an image or volume. The Input menu allows the user to select the data set to which this filter will be applied. The Scalars menu allows the user to select which scalar array will be used for gradient magnitude calculations. The Dimensionality menu determines whether the gradient magnitude will be computed in 2 or 3 dimensions. If 2 dimensions are used, the gradient magnitude will be computed from the gradients in X and Y. This filter operates on uniform rectilinear (image) data and produces image data output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkImageData"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point" 
                             number_of_components="1"/>
           <Documentation>
             Set the input to the Gradient Magnitude filter.
           </Documentation>
      </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
            <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             Select the scalar array to use in computing the gradient magnitude.
           </Documentation>
     </StringVectorProperty>

     <IntVectorProperty 
        name="Dimensionality" 
        command="SetDimensionality" 
        number_of_elements="1"
        default_values="3" >
       <EnumerationDomain name="enum">
         <Entry value="2" text="Two"/>
         <Entry value="3" text="Three"/>
       </EnumerationDomain>
       <Documentation>
         Select whether to compute the gradient magnitude in two or three dimensions.
       </Documentation>
     </IntVectorProperty>
   <!-- End Gradient -->
   </SourceProxy>

   <SourceProxy name="LinearExtrusionFilter" class="vtkPVLinearExtrusionFilter"
    label="Linear Extrusion">
    <Documentation
       long_help="This filter creates a swept surface defined by translating the input along a vector."
       short_help="Generate a linear swept surface.">
The Linear Extrusion filter creates a swept surface by translating the input data set along a specified vector. This filter is intended to operate on 2D polygonal data. The Input menu allows the user to select the data set to which this filter will be applied. The three Vector entry boxes specify the X, Y, and Z components of the vector along which to sweep the input. The value of the Scale factor entry determines the distance along the vector the data set will be translated. (A scale factor of 0.5 will move the data set half the length of the vector, and a scale factor of 2 will move it twice the vector's length.)
The Capping check box indicates whether to cap the ends of the swept surface. Capping works by placing a copy of the input data set on either end of the swept surface, so it behaves properly if the input is a 2D surface composed of filled polygons. If the input data set is a closed solid (e.g., a sphere), then if capping is on, two copies of the data set will be displayed on output (the second translated from the first one along the specified vector). If instead capping is off, then an input closed solid will produce no output.
The Piece invariant check box determines whether the output will be the same regardless of the number of processors used to compute the result. The difference is whether there are internal polygonal faces on the processor boundaries. This filter operates on polygonal data and produces polygonal data output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Linear Extrusion filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty
        name="ScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        animateable="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the amount of extrusion this filter should perform.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Vector"
        command="SetVector"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Set the direction for the extrusion.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="Capping" 
        command="SetCapping" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to draw endcaps.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn this option to to produce the same results regardless of the number of processors used. Turn this off if you do want to process ghost levels and do not mind seams.
       </Documentation>
     </IntVectorProperty>
   <!-- End LinearExtrusionFilter -->
   </SourceProxy>

   <SourceProxy name="LoopSubdivisionFilter" class="vtkLoopSubdivisionFilter"
    label="Loop Subdivision">
    <Documentation
       long_help="This filter iteratively divides each triangle into four triangles.  New points are placed so the output surface is smooth."
       short_help="Create a higher resolution and smoother surface.">
The Loop Subdivision filter increases the granularity of a polygonal mesh. It works by dividing each triangle in the input into four new triangles. It is named for Charles Loop, the person who devised this subdivision scheme. This filter only operates on triangles, so a data set that contains other types of polygons should be passed through the Triangulate filter before applying this filter to it. The Input menu allows the user to select the data set to which this filter will be applied. The Number of divisions slider specifies the number of subdivision iterations to be performed. (For example, if the number of divisions is 2, the triangles in the initial mesh will each be divided into four new triangles. Then those new triangles will be further subdivided.) This filter only operates on polygonal data (specifically triangle meshes), and it produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Loop Subdivision filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfSubdivisions" 
        command="SetNumberOfSubdivisions" 
        number_of_elements="1"
        animateable="1"
        default_values="1"
        label="Number of Subdivisions"> 
       <IntRangeDomain name="range" min="1" max="4"/>
       <Documentation>
         Set the number of subdivision iterations to perform. Each subdivision divides single triangles into four new triangles.
       </Documentation>
     </IntVectorProperty>
   <!-- End LoopSubdivisionFilter -->
   </SourceProxy>

   <SourceProxy name="MaskPoints" class="vtkMaskPoints"
    label="Mask Points">
    <Documentation
          long_help="Reduce the number of points.  This filter is often used before glyphing.  Generating vertices is an option."
          short_help="Reduce the number of points.">
The Mask Points filter reduces the number of points in the data set. It operates on any type of data set, but produces only points / vertices. This filter is often used before the Glyph filter, but now the basic point-masking functionality is available on the Parameters page for the Glyph filter.
The Input menu allows the user to select the data set to which this filter will be applied. The value in the On ratio thumb wheel specifies the ratio of points to retain in the output. (For example, if the on ratio is 3, then the output will contain 1/3 as many points -- up to the Max. points value -- as the input.) The Max. points thumb wheel determines the maximum number of points that will appear in the output. The Offset thumb wheel specifies the point in the data set from which to start masking. If the Random check box is marked, then the output points will be selected randomly from the input; otherwise every nth point (specified by the on ratio) will be selected. Selecting points at random is helpful to avoid striping when masking the points of a structured data set. If the Generate vertices option is checked, then a vertex cell will be created for each point in the output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Mask Points filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="OnRatio" 
        command="SetOnRatio" 
        number_of_elements="1"
        default_values="2" > 
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         Retain 1 / (On Ratio) points in the output dataset.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfPoints" 
        command="SetMaximumNumberOfPoints" 
        number_of_elements="1"
        default_values="5000"
        label="Maximum Number of Points"> 
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         Set the maximum number of points in the output dataset.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Offset" 
        command="SetOffset" 
        number_of_elements="1"
        animateable="1"
        default_values="0" > 
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         Begin masking from this point id.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="RandomMode" 
        command="SetRandomMode" 
        number_of_elements="1"
        default_values="0"
        label="Random"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to randomly select points or to subsample regularly.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="GenerateVertices" 
        command="SetGenerateVertices" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Specify whether to generate vertex cells as the topography of the output. If on, the geometry (vertices) will be displayed in the rendering window; otherwise no geometry will be displayed.
       </Documentation>
     </IntVectorProperty>
   <!-- End MaskPoints -->
   </SourceProxy>

   <SourceProxy name="Median" class="vtkImageMedian3D">
    <Documentation>
The Median filter operates on uniform rectilinear (image or volume) data and produces uniform rectilinear output. It replaces the scalar value at each pixel / voxel with the median scalar value in the specified surrounding neighborhood (Kernel Size). From the Input menu, the user can select the data set on which to perform this calculation. The Scalar menu determines which scalar array will be used to determine the median. The Kernel Size entry boxes specify the number of pixels / voxels in each dimension to use in computing the median to assign to each pixel / voxel. If the kernel size in a particular dimension is 1, then the median will not be computed in that direction. Since the median operation removes outliers, this filter is useful for removing high-intensity, low-probability noise (shot noise).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point" 
                            number_of_components="1"/>
          <Documentation>
            Set the input to the Median filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             Select the scalar array to use in computing the median.
           </Documentation>
     </StringVectorProperty>

     <IntVectorProperty 
        name="KernelSize" 
        command="SetKernelSize" 
        number_of_elements="3"
        default_values="1 1 1" > 
       <IntRangeDomain name="range"/>
       <Documentation>
         Specify the size in each dimension of the kernel (neighborhood) in which to compute the median.
       </Documentation>
     </IntVectorProperty>
   <!-- End Median -->
   </SourceProxy>

   <SourceProxy name="MeshQuality" class="vtkMeshQuality"
    label="Mesh Quality">
    <Documentation
       long_help="This filter creates a new cell array containing a geometric measure of each cell's fitness. Different quality measures can be chosen for different cell shapes."
       short_help="Evaluate geometric mesh quality.">
This filter creates a new cell array containing a geometric measure of each cell's fitness. Different quality measures can be chosen for different cell shapes. Supported shapes include triangles, quadrilaterals, tetrahedra, and hexahedra. For other shapes, a value of 0 is assigned.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Mesh Quality filter.
          </Documentation>
     </InputProperty>
     <IntVectorProperty
        name="TriangleQualityMeasure"
        command="SetTriangleQualityMeasure"
        number_of_elements="1"
        default_values="2">
       <EnumerationDomain name="enum">
         <Entry value="28" text="Area"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="3" text="Aspect Frobenius"/>
         <Entry value="9" text="Condition"/>
         <Entry value="15" text="Distortion"/>
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="8" text="Maximum Angle"/>
         <Entry value="6" text="Minimum Angle"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
       </EnumerationDomain>
       <Documentation>
         Select the quality measure used to evaluate triangle quality. The radius ratio is the size of a circle circumscribed by a triangle's 3 vertices divided by the size of a circle tangent to a triangle's 3 edges. The edge ratio is the ratio of the longest edge length to the shortest edge length.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty
        name="QuadQualityMeasure"
        command="SetQuadQualityMeasure"
        number_of_elements="1"
        default_values="0">
       <EnumerationDomain name="enum">
         <Entry value="28" text="Area"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="9" text="Condition"/>
         <Entry value="15" text="Distortion"/>
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="5" text="Maximum Aspect Frobenius"/>
         <Entry value="5" text="Maximum Aspect Frobenius"/>
         <Entry value="16" text="Maximum Edge Ratio"/>
         <Entry value="4" text="Mean Aspect Frobenius"/>
         <Entry value="6" text="Minimum Angle"/>
         <Entry value="23" text="Oddy"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="11" text="Shear"/>
         <Entry value="24" text="Shear and Size"/>
         <Entry value="17" text="Skew"/>
         <Entry value="20" text="Stretch"/>
         <Entry value="18" text="Taper"/>
         <Entry value="26" text="Warpage"/>
       </EnumerationDomain>
       <Documentation>
         Select the quality measure used to evaluate quadrilateral quality.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty
        name="TetQualityMeasure"
        command="SetTetQualityMeasure"
        number_of_elements="1"
        default_values="2">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="3" text="Aspect Frobenius"/>
         <Entry value="6" text="Minimum Dihedral Angle"/>
         <Entry value="7" text="Collapse Ratio"/>
         <Entry value="29" text="Aspect Beta"/>
         <Entry value="27" text="Aspect Gamma"/>
         <Entry value="19" text="Volume"/>
         <Entry value="9" text="Condition"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="15" text="Distortion"/>
       </EnumerationDomain>
       <Documentation>
         Select the quality measure used to evaluate tetrahedral quality. The radius ratio is the size of a sphere circumscribed by a tetrahedron's 4 vertices divided by the size of a circle tangent to a tetrahedron's 4 faces. The edge ratio is the ratio of the longest edge length to the shortest edge length. The collapse ratio is the minimum ratio of height of a vertex above the triangle opposite it divided by the longest edge of the opposing triangle across all vertex/triangle pairs.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty
        name="HexQualityMeasure"
        command="SetHexQualityMeasure"
        number_of_elements="1"
        default_values="5">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="4" text="Average Aspect Frobenius"/>
         <Entry value="5" text="Maximal Aspect Frobenius"/>
         <Entry value="16" text="Maximum Edge Ratio"/>
         <Entry value="17" text="Skew"/>
         <Entry value="18" text="Taper"/>
         <Entry value="19" text="Volume"/>
         <Entry value="20" text="Stretch"/>
         <Entry value="21" text="Diagonal"/> 
         <Entry value="22" text="Dimension"/>
         <Entry value="23" text="Oddy"/>
         <Entry value="9" text="Condition"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="11" text="Shear"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="24" text="Shear and Size"/>
         <Entry value="15" text="Distortion"/>
       </EnumerationDomain>
       <Documentation>
         Select the quality measure used to evaluate hexahedral quality.
       </Documentation>
     </IntVectorProperty>
   <!-- End MeshQuality -->
   </SourceProxy>

   <SourceProxy name="PolyDataNormals" class="vtkPPolyDataNormals"
    label="Normals Generation">
    <Documentation
       long_help="This filter will produce surface normals used for smooth shading.  Spltting is used to avoid smoothing across feature edges."
       short_help="Produce surface point normals.">
The Normals generation filter generates surface normals at the points of the input polygonal data set to provide smooth shading of the data set. The resulting data set is also polygonal. The filter works by calculating a normal vector for each polygon in the data set and then averaging the normals at the shared points.
In creating surface normals, if the angle between two polygons at a shared edge is larger than the value of the Feature angle slider, then that edge is considered a feature edge. If Splitting is turned on, then the mesh will be split along feature edges, allowing points to be duplicated. Because the duplicated points are no longer shared between the polygons meeting at the feature edge, a normal at these points will be created per polygon rather than averaging the polygon normals to produce one normal at each point. This allows the feature edges to remain "sharp" after shading.
Generally the normals for a data set should either all point inward or all point outward. If the Consistency check is on, then this filter will reorder the points of cells that whose normal vectors are oriented the opposite direction from the rest of those in the data set. If the Flip normals option is checked, this filter will reverse the normal direction (and reorder the points) for all polygons in the data set. You might want to do this if your viewing position will be inside the data set instead of outside of it. Sometimes you may have more than two polygons sharing an edge (i.e., a non-manifold edge). When this is the case and the Consistency option is checked, then if the Non-manifold check is on, this filter will try to maintain consistent normals across non-manifold edge, but doing this can corrupt the ordering of polygons at these edges.
This filter computes the normals at the points in the data set. In the process of doing this it computes polygon normals too. If you want these normals to be passed to the output of this filter, turn on the Cell normals option.
If this filter is run in parallel, the resulting data set will have seams along the processor boundaries unless the Piece invariant check box is marked.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Normals Generation filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty 
        name="FeatureAngle" 
        command="SetFeatureAngle" 
        number_of_elements="1"
        default_values="30" > 
       <DoubleRangeDomain name="range" min="0" max="180"/>
       <Documentation>
         This angle is used to define a feature edge. If the surface normal between two adjacent triangles is at least as large as this Feature Angle, a feature edge exists. Points are duplicated along these feature edges.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="Splitting" 
        command="SetSplitting" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn on/off the splitting of sharp edges. If sharp edges are split, then points are duplicated along these edges, and separate normals are computed for both sets of points to give crisp (rendered) surface definition.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Consistency" 
        command="SetConsistency" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn on/off the enforcement of consistent polygon ordering.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="FlipNormals" 
        command="SetFlipNormals" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to reverse the direction of all the normals, changing the meaning of front and back.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="NonManifoldTraversal" 
        command="SetNonManifoldTraversal" 
        number_of_elements="1"
        default_values="1"
        label="Non-Manifold Traversal"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn on/off traversal across non-manifold edges. Not traversing non-manifold edges will prevent problems where the consistency of polygonal ordering is corrupted due to topological loops.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeCellNormals" 
        command="SetComputeCellNormals" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn on/off the computation of cell normals (in addition to point normals typically computed by this filter).
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="PieceInvariant" 
        command="SetPieceInvariant" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn this option to to produce the same results regardless of the number of processors used. Turn this off if you do want to process ghost levels and do not mind seams.
       </Documentation>
     </IntVectorProperty>
   <!-- End  PolyDataNormals -->
   </SourceProxy>

   <SourceProxy name="OutlineFilter" class="vtkPOutlineFilter"
     label="Outline">
     <Documentation
        long_help="This filter generates a bounding box representation of the input."
        short_help="Generates a bounding box.">
The Outline filter generates an axis-aligned bounding box for the input data set. The Input menu specifies the data set for which to create a bounding box. This filter operates on any type of data set and produces polygonal output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Outline filter.
           </Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
   <!-- End  OutlineFilter -->
   </SourceProxy>

   <SourceProxy name="OutlineCornerFilter" class="vtkPOutlineCornerFilter"
    label="Outline Corners">
    <Documentation
       long_help="This filter generates a bounding box representation of the input.  It only displays the corners of the bounding box."
       short_help="Generates corners of a bounding box.">
The Outline Corners filter generates the corners of a bounding box for the input data set (specified by the Input menu). The Corner factor slider specifies the relative length of the corners along the corresponding edges. This filter produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Outline Corners filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty
        name="CornerFactor"
        command="SetCornerFactor"
        number_of_elements="1"
        default_values="0.2" >
       <DoubleRangeDomain name="range" min="0.001" max="0.5" />
       <Documentation>
         Set the size of the corners as a percentage of the length of the corresponding bounding box.
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End  OutlineCornerFilter -->
   </SourceProxy>

   <SourceProxy name="OctreeDepthScalars" class="vtkHyperOctreeDepth"
     label="Octree Depth Scalars">
     <Documentation
        long_help="This filter adds a scalar to each leaf of the octree that represents the leaf's depth within the tree."
        short_help="Computes cell depths within the octree.">
The vtkHyperOctreeDepth filter adds a scalar to each leaf of the octree that represents the leaf's depth within the tree.
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkHyperOctree"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Octree Depth Scalars filter.
           </Documentation>
      </InputProperty>
   <!-- End  OctreeDepthScalars-->
   </SourceProxy>

   <SourceProxy name="OctreeDepthLimit" class="vtkHyperOctreeLimiter"
     label="Octree Depth Limit">
     <Documentation
        long_help="This filter takes in a octree and produces a new octree which is no deeper than the maximum specified depth level."
        short_help="Reduce an octree's resolution.">
The Octree Depth Limit filter takes in an octree and produces a new octree that is nowhere deeper than the maximum specified depth level. The attribute data of pruned leaf cells are integrated in to their ancestors at the cut level.
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkHyperOctree"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Octree Depth Limit filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty 
        name="MaximumLevel" 
        command="SetMaximumLevel" 
        number_of_elements="1"
        default_values="4" > 
       <IntRangeDomain name="range" min="3" max="255"/>
       <Documentation>
         Set the maximum depth of the output octree.
       </Documentation>
     </IntVectorProperty>
   <!-- End  OctreeDepthLimit-->
   </SourceProxy>

   <SourceProxy name="ProcessIdScalars" class="vtkProcessIdScalars"
     label="Process Id Scalars">
     <Documentation
        long_help="This filter uses colors to show how data is partitioned across processes."
        short_help="Generate point scalars from process id.">
The Process Id Scalars filter assigns a unique scalar value to each piece of the input according to which processor it resides on. If the Random option is selected, the unique value per piece will be chosen at random; otherwise it will match the process id. This filter operates on any type of data when ParaView is run in parallel. It is useful for determining whether your data is load-balanced across the processors being used. The output data set type is the same as that of the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Process Id Scalars filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="RandomMode" 
        command="SetRandomMode" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to use random id values for the various pieces.
       </Documentation>
     </IntVectorProperty>
   <!-- End PieceScalars -->
   </SourceProxy>

   <SourceProxy name="PointDataToCellData" class="vtkPointDataToCellData"
     label="Point Data to Cell Data">
     <Documentation
        long_help="Create cell attributes by averaging point attributes."
        short_help="Convert point data to cell data.">
The Point Data to Cell Data filter averages the values of the point attributes of the points of a cell to compute cell attributes. The Input menu allows the user to select the data set to which this filter will be applied. If the Pass point data option is checked, then the input point attributes will also be copied to the point attributes of the output; otherwise the output will only have cell attributes. The Point Data to Cell Data filter operates on any type of data set, and the output data set is of the same type as the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"/>
           <FixedTypeDomain name="fixed_type"/>
           <Documentation>
             Set the input to the Point Data to Cell Data filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty 
        name="PassPointData" 
        command="SetPassPointData" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Control whether the input point data will be passed to the output. If on, then the input point data is passed through to the output; otherwise, only generated cell data is placed into the output.
       </Documentation>
     </IntVectorProperty>
   <!-- End PointDataToCellData -->
   </SourceProxy>

   <SourceProxy name="QuadricClustering" class="vtkQuadricClustering"
    label="Quadric Clustering">
    <Documentation
       long_help="This filter is the same filter used to generate level of detail for ParaView.  It uses a structured grid of bins and merges all points contained in each bin."
       short_help="Simplify polygonal models.">
The Quadric Clustering filter produces a reduced-resolution polygonal approximation of the input polygonal data set. This filter is the one used by ParaView for computing LODs. It uses spatial binning to reduce the number of points in the data set; points that lie within the same spatial bin are collapsed into one representative point. The Divisions entries specify the number of bins along the X, Y, and Z axes of the data set. If Use input points is on, the representative point for each bin is selected from one of the input points that lies in that bin; the input point that produces the least error is chosen. Without this option selected, the location of the representative point is calculated to produce the least error possible for that bin, but the point will most likely not be one of the input points.
To better align pieces of the data set assigned to different processors, select Use feature edges and Use feature points. Use feature edges adjusts the representative points that contain boundary edges (along processor divisions), and Use feature points further influences the position of the feature points along the boundaries.
The Copy cell data toggle controls whether cell-centered data from the input should be copied to the output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Quadric Clustering filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfDivisions" 
        command="SetNumberOfDivisions" 
        number_of_elements="3"
        default_values="50 50 50"
        label="Number of Dimensions" > 
       <IntRangeDomain name="range"/>
       <Documentation>
         Set the number of spatial bins in each dimension.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseInputPoints" 
        command="SetUseInputPoints" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to use points from the input as the representative points or to calculate optimum representative points for each bin.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseFeatureEdges" 
        command="SetUseFeatureEdges" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to use feature edge quadrics to match up the boundaries between pieces.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseFeaturePoints" 
        command="SetUseFeaturePoints" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to use feature point quadrics to align piece boundaries.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="CopyCellData" 
        command="SetCopyCellData" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether the cell data should be copied from input to output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseInternalTriangles"
        command="SetUseInternalTriangles"
        number_of_elements="1"
        default_values="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to include triangles completely contained in a spatial bin in the computation of the bin's quadrics. When this option is off, the filters operates faster, but the resulting surface may not be as well-behaved.
       </Documentation>
     </IntVectorProperty>
   <!-- End QuadricClustering -->
   </SourceProxy>

   <SourceProxy name="BrownianPoints" class="vtkBrownianPoints" label="Random Vectors">
    <Documentation
       long_help="This filter creates a new 3 component point data array and sets it as the default vectors.  It uses a random number generator to create values."
       short_help="Create a new random vector array.">
The Random Vectors filter generates a point-centered array of random vectors. It uses a random number generator to determine the components of the vectors. The Min. speed and Max. speed values determine the range of the vector magnitudes. This filter operates on any type of data set, and the output data set will be of the same type as the input.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Random Vectors filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty 
        name="MinimumSpeed" 
        command="SetMinimumSpeed" 
        number_of_elements="1"
        default_values="0" > 
       <DoubleRangeDomain name="range" min="0" />
       <Documentation>
         Set the minimum length of the random point vectors generated.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty 
        name="MaximumSpeed" 
        command="SetMaximumSpeed" 
        number_of_elements="1"
        default_values="1" > 
       <DoubleRangeDomain name="range" min="0"/>
       <Documentation>
         Set the maximum length of the random point vectors generated.
       </Documentation>
     </DoubleVectorProperty>
   <!-- End BrownianPoints -->
   </SourceProxy>

   <SourceProxy name="ReflectionFilter" class="vtkReflectionFilter" 
    label="Reflect">
    <Documentation
       long_help="This filter takes the union of the input and its reflection over an axis-aligned plane."
       short_help="Reflect input over an axis aligned plane.">
The Reflect filter reflects the input data set across the specified plane. If the Copy Input check box is marked, the output is the union of the input data set and its reflection. Otherwise the output will contain only the reflection of the input data. If the value chosen from the Plane menu is X, Y, or Z, the value of the Center entry determines where the plane is placed along the specified axis. The other six entries, X Min, X Max, etc., place the reflection plane at the specified face of the bounding box of the input data set. This filter operates on any type of data set and produces an unstructured grid output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Reflect filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="Plane" 
        command="SetPlane" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="X Min"/>
         <Entry value="1" text="Y Min"/>
         <Entry value="2" text="Z Min"/>
         <Entry value="3" text="X Max"/>
         <Entry value="4" text="Y Max"/>
         <Entry value="5" text="Z Max"/>
         <Entry value="6" text="X"/>
         <Entry value="7" text="Y"/>
         <Entry value="8" text="Z"/>
       </EnumerationDomain>
       <Documentation>
         Select which plane to reflect across.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Center"
        command="SetCenter"
        number_of_elements="1"
        animateable="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If the selected Plane is X, Y, or Z, then this value specifies the center of the reflection plane.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="CopyInput"
        command="SetCopyInput"
        number_of_elements="1"
        default_values="1">
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to include both the input and its reflection in the output.
       </Documentation>
     </IntVectorProperty>
   <!-- End ReflectionFilter -->
   </SourceProxy>

   <SourceProxy name="RibbonFilter" class="vtkRibbonFilter"
    label="Ribbon">
    <Documentation
       long_help="This filter generates ribbon surface from lines.  It is useful for displaying streamlines."
       short_help="Create ribbon surfaces from lines.">
The Ribbon filter creates ribbons from the lines in the input data set. This filter is useful for visualizing streamlines. Both the input and output of this filter are polygonal data. The input data set must also have at least one point-centered vector array.
The vectors and scalars for use in this filter can be selected from the Vectors and Scalars menus respectively. If the Vary width option is on, the width of the ribbons will be scaled according to the selected scalars. If Use default normal is off, the selected vector array will be used as the normals of the ribbons. If Use default normal is on, the normal for the ribbons is specified by the values in the Default normal entry boxes.
The Width entry box specifies half the width of the ribbons. If Vary width is on, then the Width value specified is half the minimum width of the ribbons. The Angle value determines the orientation of the ribbons; it specifies the offset angle (in degrees) of the ribbon from the normal line.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array1" attribute_type="point"
                            number_of_components="3" optional="1"/>
          <InputArrayDomain name="input_array2" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <Documentation>
            Set the input to the Ribbon filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
           <ArrayListDomain name="array_list" attribute_type="Scalars"
                            input_domain_name="input_array2">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             Select the input scalars by which to vary the width of the ribbons.
           </Documentation>
     </StringVectorProperty> 

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Vectors">
           <ArrayListDomain name="array_list" attribute_type="Vectors"
                            input_domain_name="input_array1">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             Select the input vectors for calculating the normals of the ribbons.
           </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="Width"
        command="SetWidth"
        number_of_elements="1"
        default_values="1" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.01">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         If varying the ribbon's width, this value is the minimum ribbon width. If not varying the width, this value is half the width of the ribbon.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Angle"
        command="SetAngle"
        number_of_elements="1"
        default_values="0" >
       <DoubleRangeDomain name="range" min="0" max="360" />
       <Documentation>
         Set the offset angle (in degrees) of the ribbon from the line normal.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="UseDefaultNormal" 
        command="SetUseDefaultNormal" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         When this option is off, default normals will be generated if the input contains no normals. If on, the default normal will be used.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="DefaultNormal"
        command="SetDefaultNormal"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the normal to use if Use Default Normal is on.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="VaryWidth" 
        command="SetVaryWidth" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle the variation of ribbon width with scalar value.
       </Documentation>
     </IntVectorProperty>
   <!-- End RibbonFilter -->
   </SourceProxy>

   <SourceProxy name="RotationalExtrusionFilter" 
                class="vtkRotationalExtrusionFilter"
                label="Rotational Extrusion">
    <Documentation
       long_help="This filter generates a swept surface while translates the input along a circular path."
       short_help="Generates a swept surface using a rotational path.">
The Rotational Extrusion filter forms a surface by rotating the input about the Z axis. This filter is intended to operate on 2D polygonal data. The Input menu allows the user to select the data set to which this filter will be applied. The value of the Resolution thumb wheel specifies the number of steps taken in rotating from 0 to the value specified in the Angle entry box. The Translation entry box determines the distance along the Z axis to be covered as the data set is rotated. Specifying a non-zero Translation value allows you to create a corkscrew or spring effect. The Delta radius entry box controls how much the radius of the rotation increases as the new data set is swept out.
The Capping check box controls whether to close the open ends of the swept surface. Capping works by placing a copy of the input data set on either end of the swept surface, so it behaves properly if the input is a 2D surface composed of filled polygons. If the input data set is a closed solid (e.g., a sphere), then either two copies of the data set will be drawn or no surface will be drawn. No surface is drawn if either capping is on or if the two surfaces would occupy exactly the same 3D space (e.g., Angle is a multiple of 360, and Translation and Delta radius are 0).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Rotational Extrusion filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="Resolution" 
        command="SetResolution" 
        number_of_elements="1"
        default_values="12" > 
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         Control the number of intermediate node points used in performing the sweep.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Capping" 
        command="SetCapping" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to draw endcaps.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Angle"
        command="SetAngle"
        number_of_elements="1"
        animateable="1"
        default_values="360" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the angle of rotation in degrees.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Translation"
        command="SetTranslation"
        number_of_elements="1"
        animateable="1"
        default_values="0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Set the total amount of translation along the Z axis during the sweep process.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="DeltaRadius"
        command="SetDeltaRadius"
        number_of_elements="1"
        default_values="0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Set the change in radius during the sweep process.
       </Documentation>
     </DoubleVectorProperty>
   <!-- End RotationalExtrusionFilter -->
   </SourceProxy>

   <SourceProxy name="ShrinkFilter" class="vtkShrinkFilter"
     label="Shrink">
     <Documentation
        long_help="This filter shrinks each input cell so they pull away from their neighbors."
        short_help="Shrink each input cell.">
The Shrink filter causes the individual cells of a data set to break apart from each other by moving each cell's points toward the centroid of the cell. (The centroid of a cell is the average position of its points.) The Shrink factor scale determines how far the points will move. A value of 0 positions the points at the centroid of the cell; a value of 1 leaves them at their original positions. This filter operates on any type of data set and produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Shrink filter.
           </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="ShrinkFactor"
         command="SetShrinkFactor"
         number_of_elements="1"
         animateable="1"
         default_values="0.5" >
        <DoubleRangeDomain name="range" min="0" max="1" />
        <Documentation>
          Set the percentage by which to shrink the input cells.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End ShrinkFilter -->
   </SourceProxy>

   <SourceProxy name="SmoothPolyDataFilter" class="vtkSmoothPolyDataFilter"
    label="Smooth">
    <Documentation
       long_help="This filter smooths a polygonal surface by iteratively moving points toward their neighbors."
       short_help="Smooth a polygonal surface without adding more points.">
The Smooth filter operates on a polygonal data set by iteratively adjusting the position of the points using Laplacian smoothing. (Because this filter only adjusts point positions, the output data set is also polygonal.) This results in better-shaped cells and more evenly distributed points. The Num. iterations thumb wheel specifies the maximum number of smoothing iterations to perform. The Convergence slider limits the maximum motion of any point. It is expressed as a fraction of the length of the diagonal of the bounding box of the data set. If the maximum point motion during a smoothing iteration is less than the Convergence value, the smoothing operation terminates.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Smooth filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfIterations" 
        command="SetNumberOfIterations" 
        number_of_elements="1"
        animateable="1"
        default_values="20"
        label="Number of Iterations"> 
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         Set the number of smoothing iterations to perform. More iterations produces better smoothing.
       </Documentation>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="Convergence"
         command="SetConvergence"
         number_of_elements="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range" min="0" max="1" />
        <Documentation>
          Set the convergence criterion for the iteration process. Smaller numbers result in more smoothing iterations.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End SmoothPolyDataFilter -->
   </SourceProxy>

   <SourceProxy name="Stripper" class="vtkStripper"
    label="Triangle Strips">
    <Documentation
       long_help="This filter uses a greedy algorithm to convert triangles into triangle strips"
       short_help="Convert triangles into triangle strips.">
The Triangle Strips filter converts triangles into triangle strips and lines into polylines. The Max. length slider determines the maximum number of triangles or lines to merge into a strip. This filter operates on polygonal data sets and produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Triangle Strips filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="MaximumLength" 
        command="SetMaximumLength" 
        number_of_elements="1"
        default_values="1000" > 
       <IntRangeDomain name="range" min="4" max="100000"/>
       <Documentation>
         Set the maximum number of triangles / lines to include in a triangle strip or polyline.
       </Documentation>
     </IntVectorProperty>
   <!-- End Stripper -->
   </SourceProxy>

   <SourceProxy name="Subdivide" class="vtkLinearSubdivisionFilter">
    <Documentation
       long_help="This filter iteratively divide triangles into four smaller triangles.  New points are placed linearly so the output surface matches the input surface."
       short_help="Creates a surface with more triangles than the input.">
The Subdivide filter iteratively divides each triangle in the data set into 4 new triangles. Three new points are added per triangle -- one at the midpoint of each edge. The image below shows a triangle with the new points inserted and the appropriate edges added to form the four new triangles. The Num. divisions slider determines the number of subdivision passes the filter will take through the data. This filter operates only on polygonal data containing triangles, so run your polygonal data through the Triangulate filter first if it is not composed of triangles. The output of this filter is also polygonal.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Subdivide filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfSubdivisions" 
        command="SetNumberOfSubdivisions" 
        number_of_elements="1"
        default_values="1"
        label="Number of Subdivisions"> 
       <IntRangeDomain name="range" min="1" max="4"/>
       <Documentation>
         Set the number of subdivision iterations  to perform.
       </Documentation>
     </IntVectorProperty>
   <!-- End Subdivide -->
   </SourceProxy>

   <SourceProxy name="TessellatorFilter" class="vtkTessellatorFilter" 
     label="Tessellate">
     <Documentation
        long_help="Tessellate nonlinear curves, surfaces, and volumes with lines, triangles, and tetrahedra."
        short_help="Polygonize a mesh.">
The Tessellate filter tessellates cells with nonlinear geometry and/or scalar fields into a simplicial complex with linearly interpolated field values that more closely approximate the original field. This is useful for the quadratic cells supported by VTK. There are several settings that affect the tessellation.
The Output Dimension specifies whether nonlinear cells should have their volumes, surfaces, or edges tessellated. When the Output Dimension is 3, 3-D cells produce tetrahedra, 2-D cells produce triangles, and 1-D cells produce line segments. When the Output Dimension is 2, 3-D cells will have their boundaries tessellated with triangles. When the Output Dimension is 1, then all cells except points produce line segments.
The Max Chord Error setting is the maximum allowed distance between the midpoint of any output edge and the original nonlinear geometry.
The Max Field Error setting is a per-field error, also sampled at midpoints, but comparing the linear and nonlinear field values.
The Max Num Of Subdivisions setting specifies the maximum number of times an edge may be subdivided. Increasing this number allows further refinement but can drastically increase the computational and storage requirements, especially when the Output Dimension is 3.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
             <DataType value="vtkDataSet"/>
             <DataType value="vtkUnstructuredGrid"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Tessellate filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="OutputDimension"
        command="SetOutputDimension"
        number_of_elements="1"
        default_values="3">
       <IntRangeDomain name="range" min="1" max="3"/>
       <Documentation>
         Set the maximum dimensionality of the output tessellation. Cells of higher dimension will be reduced to their boundaries.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="ChordError"
        command="SetChordError"
        number_of_elements="1"
        default_values="1e-3">
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Set the maximum chord error allowed at any edge midpoint in the output tessellation.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="FieldError2"
        command="SetFieldCriterion"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"
        label="Field Error">
        <Documentation>
          Set the maximum field error allowed at any edge midpoint in the output tessellation.
        </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="MaximumNumberOfSubdivisions"
        command="SetMaximumNumberOfSubdivisions"
        number_of_elements="1"
        default_values="3"
        label="Maximum Number of Subdivisions">
       <IntRangeDomain name="range" min="0" max="8"/>
       <Documentation>
         Set the maximum number of subdivision iterations to perform.
       </Documentation>
     </IntVectorProperty>

     <Property
        name="ResetFieldCriteria"
        command="ResetFieldCriteria"
        immediate_update="1">
     </Property>
   <!-- End TessellatorFilter -->
   </SourceProxy>

   <SourceProxy name="DataSetTriangleFilter" class="vtkDataSetTriangleFilter"
     label="Tetrahedralize">
     <Documentation
        long_help="This filter converts 3-d cells to tetrahedrons and polygons to triangles.  The output is always of type unstructured grid."
        short_help="Convert to tetrahedrons and triangles.">
The Tetrahedralize filter converts the 3D cells of any type of data set to tetrahedrons and the 2D ones to triangles. This filter always produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Tetrahedralize filter.
           </Documentation>
      </InputProperty>
   <!-- End DataSetTriangleFilter -->
   </SourceProxy>

   <SourceProxy name="TransformFilter" class="vtkTransformFilter"
    label="Transform">
    <Documentation
       long_help="This filter applies transformation to the polygons."
       short_help="Transform polygonal data.">
The Transform filter allows you to specify the position, size, and orientation of polygonal, unstructured grid, and curvilinear data sets. You can interactively perform these affine transformations on the data by using the box widget, and the parameters can also be controlled manually. See section 7.4 for the details of using the box widget and manually setting its parameters. The output of this filter will have the same data set type as the input.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPointSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Transform filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="Transform" command="SetTransform">
           <ProxyGroupDomain name="groups">
              <Group name="transforms"/>
           </ProxyGroupDomain>
           <Documentation>
             Set the transform to apply to the input dataset.
           </Documentation>
     </ProxyProperty>
   <!-- End TransformFilter -->
   </SourceProxy>

   <SourceProxy name="TriangleFilter" class="vtkTriangleFilter"
     label="Triangulate">
     <Documentation
        long_help="This filter converts polygons and triangle strips to basic triangles."
        short_help="Convert polygonal data to triangles.">
The Triangulate filter decomposes polygonal data into only triangles, points, and lines. It separates triangle strips and polylines into individual triangles and lines, respectively. The output is polygonal data. Some filters that take polygonal data as input require that the data be composed of triangles rather than other polygons, so passing your data through this filter first is useful in such situations. You should use this filter in these cases rather than the Tetrahedralize filter because they produce different output data set types. The filters referenced require polygonal input, and the Tetrahedralize filter produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Triangulate filter.
           </Documentation>
      </InputProperty>
   <!-- End TriangleFilter -->
   </SourceProxy>

   <SourceProxy name="TubeFilter" class="vtkTubeFilter" label="Tube">
    <Documentation
       long_help="Convert lines into tubes.  Normals are used to avoid cracks between tube segments."
       short_help="Convert lines into tubes.">
The Tube filter creates tubes around the lines in the input polygonal data set. The output is also polygonal. The Num. sides value determines the number of faces around the circumference of the tube. The Capping toggle specifies whether to close the end of the tube with a polygon. The Radius entry determines the radius of the tube (or the minimum radius if you are varying the radius). From the Vary radius menu, you can select whether the radius of the tube should vary, and if so, whether it should be by scalar or by vector. If the radius is varied by scalar, the tube radius is based on the point-based scalar values. If it is varied by vector, the vector magnitude is used. If you are varying the radius, the value in the Radius factor entry determines the maximum radius by specifying a multiplier of the Radius value.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Tube filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="NumberOfSides" 
        command="SetNumberOfSides" 
        number_of_elements="1"
        animateable="1"
        default_values="6"
        label="Number of Sides"> 
       <IntRangeDomain name="range" min="3"/>
       <Documentation>
         Set the number of sides for the tube.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Capping" 
        command="SetCapping" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to draw endcaps on the tube.
       </Documentation>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="Radius"
         command="SetRadius"
         number_of_elements="1"
         default_values="1.0" >
        <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.01">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>
          Set the radius of the tube. If the radius is varying, then this value is the minimum radius.
        </Documentation>
      </DoubleVectorProperty>

     <IntVectorProperty 
        name="VaryRadius" 
        command="SetVaryRadius" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="By Scalar"/>
         <Entry value="2" text="By Vector"/>
       </EnumerationDomain>
       <Documentation>
         Select whether/how to vary the radius of the tube.
       </Documentation>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="RadiusFactor"
         command="SetRadiusFactor"
         number_of_elements="1"
         default_values="10" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          Set the maximum tube radius in terms of a multiple of the minimum radius. If not varying the radius, this value has no effect.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End TubeFilter -->
   </SourceProxy>

   <SourceProxy name="WarpScalar" class="vtkWarpScalar" label="Warp (scalar)">
     <Documentation
        long_help="This filter moves point coordinates along a vector scaled by a point attribute.  It can be used to produce carpet plots."
        short_help="Warp point scalars into a spatial elevation plot.">
The Warp (scalar) filter translates the points of the input data set along a vector by a distance determined by the specified scalars (selected from the Scalars menu). The Scale factor entry allows you to rescale the scalar values used in warping the data.
The Normal entries specify the direction in which to warp the geometry if the Use normal option is checked. If Use normal and X-Y plane are off, the data set will be warped along its normals array. (If no normals array exists, the Normal value will be used.) If X-Y plane is on, the Z-values in the data set are considered to be scalars, and warping is done along the Z axis. This is useful for creating carpet plots. Any scalars in the data set are copied to the output, so the data can be colored by them.
This filter operates on polygonal, curvilinear, and unstructured grid data sets containing single-component scalar arrays. Because it only changes the positions of the points, the output data set type is the same as that of the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="1"/>
           <Documentation>
             Set the input to the Warp (scalar) filter.
           </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             Select the input scalars by which to warp the dataset.
           </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="ScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        animateable="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Multiply the scalar at a given point by this value to determine the magnitude of the change vector for that point.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Normal"
        command="SetNormal"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the direction along which to warp the dataset.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="UseNormal" 
        command="SetUseNormal" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If point normals are present in the dataset, toggle whether to use a single Normal value (On) or the normals from the dataset (Off).
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="XYPlane" 
        command="SetXYPlane" 
        number_of_elements="1"
        default_values="0"
        label="XY Plane">
       <BooleanDomain name="bool"/>
       <Documentation>
         If this option is on, then the Z-coordinates from the input are considered to be the scalar values, and the displacement is along the Z axis.
       </Documentation>
     </IntVectorProperty>
   <!-- End WarpScalar -->
   </SourceProxy>

   <SourceProxy name="WarpVector" class="vtkWarpVector" label="Warp (vector)">
     <Documentation
        long_help="This filter displaces point coordinates along a vector attribute.  It is useful for showing mechanical deformation."
        short_help="Warp (displace) the geometry with a given vector field.">
The Warp (vector) filter translates the points of the input data set using a specified vector array. The vector array chosen specifies a vector per point in the input. Each point is translated along its vector by the value in the Scale factor entry box. This filter operates on polygonal, curvilinear, and unstructured grid data sets. Because this filter only changes the positions of the points, the output data set type is the same as that of the input. This filter is available on the Toolbar.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             Set the input to the Warp (vector) filter.
           </Documentation>
      </InputProperty>

      <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         label="Vectors">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              Select the vector array by which to warp the dataset's point coordinates.
            </Documentation>
      </StringVectorProperty> 

      <DoubleVectorProperty
         name="ScaleFactor"
         command="SetScaleFactor"
         number_of_elements="1"
         default_values="1.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          Each component of the selected vector array will be multiplied by this value before being used to compute new point coordinates.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End WarpVector -->
   </SourceProxy>

   <SourceProxy name="AnimateWarp" class="vtkWarpVector" label="Animate Warp">
     <Documentation
        long_help="This filter displaces point coordinates along a vector attribute.  It is useful for showing mechanical deformation. This class also simplifies the animation process."
        short_help="Warp (displace) the geometry with a given vector field.">
The Warp (vector) filter translates the points of the input data set using a specified vector array. The vector array chosen specifies a vector per point in the input. Each point is translated along its vector by the value in the Scale factor entry box. This filter operates on polygonal, curvilinear, and unstructured grid data sets. Because this filter only changes the positions of the points, the output data set type is the same as that of the input. This filter is available on the Toolbar.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             Set the input to the Animate Warp filter.
           </Documentation>
      </InputProperty>

      <StringVectorProperty 
         name="SelectInputVectors" 
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         label="Vectors">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              Select the vector array by which to warp the dataset's point coordinates.
            </Documentation>
      </StringVectorProperty> 

      <DoubleVectorProperty
         name="ScaleFactor"
         command="SetScaleFactor"
         number_of_elements="1"
         default_values="1.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          Each component of the selected vector array will be multiplied by this value before being used to compute new point coordinates.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End AnimateWarp -->
   </SourceProxy>

   <SourceProxy name="Cut" class="vtkCutter">
    <Documentation
       long_help="This filter cuts a data set with a plane or sphere.  Cutting is similar to a contour.  It creates surfaces from volumes and lines from surfaces."
       short_help="Cut datasets with planes or spheres.">
The Cut filter extracts the portion of the input data set that lies along the specified plane or sphere. From the Cut Function menu, you can select whether cutting will be performed with a plane or a sphere. The appropriate 3D widget (plane widget or sphere widget) will be displayed. The parameters of the cut function can be specified interactively using the 3D widget or manually using the traditional user interface controls. Instructions for using these 3D widgets and their corresponding user interfaces are found in section 7.4.
By default, the cut lies on the specified plane or sphere. Using the Cut Offset Values portion of the interface, it is also possible to cut the data set at some offset from the original cut function. The Cut Offset Values are in the spatial units of the data set. To add a single offset, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced offsets, use the controls in the Generate range of values section. Select the number of offsets to generate using the Number of Values slider. The Range slider controls the interval in which to generate the offsets. Once the number of values and range have been selected, click the Generate button. The new offsets will be added to the Offset Values list. To delete a value from the Cut Offset Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list.
The Cut filter takes any type of data set as input. Use the Input menu to choose a data set to cut. The output of this filter is polygonal data. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Cut filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="CutFunction" command="SetCutFunction"
        label="Cut Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             Set the parameters of the cut function.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds" information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        repeat_command="1"
        set_number_command="SetNumberOfContours"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1"
        label="Cut Offset Values">
          <BoundsDomain name="bounds" mode="magnitude">
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </BoundsDomain>
          <Documentation>
            Specify a list of current offset values. This can be used to create multiple cuts with different centers. Each entry represents a new cut with center shifted by the offset value.
          </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End Cut -->
   </SourceProxy>

   <SourceProxy name="Clip" class="vtkPVClipDataSet">
    <Documentation
       long_help="Clip with an implicit plane, sphere or with scalars. Clipping does not reduce the dimensionality of the data set.  This output data type of this filter is always an unstructured grid."
       short_help="Clip with an implicit plane, sphere or with scalars.">
The Clip filter cuts away a portion of the input data set using a plane, a sphere, a box, or a scalar value. The menu in the Clip Function portion of the interface allows the user to select which implicit function to use or whether to clip using a scalar value. Making this selection loads the appropriate user interface. For the implicit functions, the appropriate 3D widget (plane, sphere, or box) is also displayed. The use of these 3D widgets, including their user interface components, is discussed in section 7.4.
If an implicit function is selected, the clip filter returns that portion of the input data set that lies inside the function. If Scalars is selected, then the user must specify a scalar array to clip according to. The clip filter will return the portions of the data set whose value in the selected Scalars array is larger than the Clip value. Regardless of the selection from the Clip Function menu, if the Inside Out option is checked, the opposite portions of the data set will be returned.
This filter operates on all types of data sets, and it returns unstructured grid data on output. This filter is available on the toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            optional="1"/>
          <Documentation>
            Set the input to the Clip filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="ClipFunction" command="SetClipFunction"
        label="Clip Type">
           <ProxyGroupDomain name="groups">
               <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             Set the parameters of the clip function.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InsideOut" 
        command="SetInsideOut" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle which portion of the dataset should be clipped away.
       </Documentation>
     </IntVectorProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             Choose the clipping scalar array.
           </Documentation>
     </StringVectorProperty> 

     <DoubleVectorProperty
        name="Value"
        command="SetValue"
        number_of_elements="1"
        default_values="0.0" >
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
          <DoubleRangeDomain name="range"/>
          <Documentation>
            Choose the scalar value with which to clip.
          </Documentation>
     </DoubleVectorProperty>
   <!-- End Clip -->
   </SourceProxy>

   <SourceProxy name="Threshold" class="vtkThreshold">
    <Documentation
       long_help="This filter extracts cells that have point or cell scalars in the specified range."
       short_help="Extract cells that satisfy a threshold criterion.">
The Threshold filter extracts the portions of the input data set whose scalars lie within the specified range. This filter operates on either point-centered or cell-centered data. To select between these two options, select either Point Data or Cell Data from the Attribute Mode menu. Once the Attribute Mode has been selected, choose the scalar array from which to threshold the data from the Scalars menu. The Lower Threshold and Upper Threshold sliders determine the range of the scalars to retain in the output. The All Scalars check box only takes effect when the Attribute Mode is set to Point Data. If the All Scalars option is checked, then a cell will only be passed to the output if the scalar values of all of its points lie within the range indicated by the Lower Threshold and Upper Threshold sliders. If unchecked, then a cell will be added to the output if the specified scalar value for any of its points is within the chosen range. This filter operates on any type of data set and produces unstructured grid output. The Threshold filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" number_of_components="1">
             <RequiredProperties>
                <Property name="SelectInputScalars" 
                          function="FieldDataSelection"/>
             </RequiredProperties>
          </InputArrayDomain>
          <Documentation>
            Set the input to the Threshold filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
           <ArrayListDomain name="array_list" 
                            attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <FieldDataDomain name="field_list">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </FieldDataDomain>
           <Documentation>
             Choose the scalar array from which to perform thresholding.
           </Documentation>
     </StringVectorProperty> 

     <DoubleVectorProperty 
        name="ThresholdBetween" 
        command="ThresholdBetween"
        number_of_elements="2"
        default_values="0 0"
        label="Threshold Range">
          <ArrayRangeDomain name="range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
          <Documentation>
            Specify the upper and lower bounds of the threshold.
          </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="AllScalars" 
        command="SetAllScalars" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If All Scalars is checked, then a cell is only included in the output if all its points are within the threshold. This is only relevant when thresholding by a point-centered array.
       </Documentation>
     </IntVectorProperty>
   <!-- End Threshold -->
   </SourceProxy>

   <SourceProxy name="Contour" class="vtkContourFilter">
    <Documentation
       long_help="Generate isolines or isosurfaces using point scalars."
       short_help="Generate isolines or isosurfaces.">
The Contour filter computes isolines or isosurfaces using a selected point-centered scalar array. The available scalar arrays are listed in the Scalars menu. The scalar range of the selected array will be displayed.
The interface for adding contour values is very similar to the one for selecting cut offsets (in the Cut filter). To add a single contour value, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced contours, use the controls in the Generate range of values section. Select the number of contour values to generate using the Number of Values slider. The Range slider controls the interval in which to generate the contour values. Once the number of values and range have been selected, click the Generate button. The new values will be added to the Contour Values list. To delete a value from the Contour Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list. If no values are in the Contour Values list when Accept is pressed, the current value of the New Value slider will be used.
In addition to selecting contour values, you can also select additional computations to perform. If any of Compute Normals, Compute Gradients, or Compute Scalars is selected, the appropriate computation will be performed, and a corresponding point-centered array will be added to the output.
The Contour filter operates on any type of data set, but the input is required to have at least one point-centered scalar (single-component) array. The output of this filter is polygonal. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="1"/>
          <Documentation>
            Set the input to the Contour filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Scalars">
          <ArrayListDomain name="array_list" attribute_type="Scalars">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            Choose which scalar array you want to contour.
          </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        set_number_command="SetNumberOfContours"
        number_of_elements="0"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>
          <Documentation>
            Specify the current contour values.
          </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="ComputeNormals" 
        command="SetComputeNormals" 
        number_of_elements="1"
        default_values="1" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute normals.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeGradients" 
        command="SetComputeGradients" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute gradients.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeScalars" 
        command="SetComputeScalars" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute scalars.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End Contour -->
   </SourceProxy>


   <SourceProxy name="Glyph" class="vtkPVGlyphFilter">
    <Documentation
       long_help="This filter generates an arrow, cone, line, sphere, or 2D glyph at each point of the input data set.  The glyphs can be oriented and scaled by the input point attributes."
       short_help="Generate a glyph symbol at each point of the input data set.">
The Glyph filter generates a glyph (i.e., an arrow, cone, line, sphere, or 2D glyph) at each point in the input data set. The glyphs can be oriented and scaled by the input point-centered scalars and vectors.
From the Glyph menu, select which symbol should be drawn at each input point. The available choices are Arrow, Cone, Line, Sphere, and Glyph2D. To change the parameters of any of the glyphs (including which 2D glyph is drawn), choose the appropriate glyph from the Glyphs submenu of the Select menu. Change the desired parameter(s) and click Accept. To return to the Glyph interface, select this filter from the Selection / Navigation Window or from the Select menu.
The Orient / Scale section of the interface determines how the point-centered scalars and vectors contribute to the orientation and scale of the widgets. The Orient Mode menu determines whether the glyphs are drawn in their original orientation (Off) or in an orientation determined by a vector array (Vector). If the input does not contain point-centered vectors, the Vector option in the Orient Mode menu will not be available.
The Scale Mode menu determines how the scale of the glyphs will be calculated. The options are to scale by the selected scalar array (Scalar), to scale by the magnitudes of the selected vector array (Vector Magnitude), to scale by each component of the selected vector array (Vector Components), or to draw the all the glyphs at the same scale (Data Scaling Off). If the input contains no point-centered scalar arrays, the Scalar option will be disabled. If it has no point-centered vector arrays, the Vector Magnitude and Vector Components entries will be unavailable. The value of the Scale Factor entry box is a multiplier that contributes to the final size of the glyphs.
The Scalars and Vectors menus list the point-centered scalar (single-component) and vector (three-component) arrays in the input data set. These menus are enabled and disabled depending on the current Orient and Scale Mode selections.
The Glyph Parameters tab also contains controls for masking the input points before glyphing. (This is a simplified version of the Mask Points filter interface.) To enable point masking, turn on the Mask Points option. When this is selected, the Max. Number of Glyphs thumbwheel sets an upper limit on the number of glyphs to display. If the Random Masking option is on, the input points to glyph will be randomly selected; otherwise every second point will be glyphed, starting from the first point id.
The Glyph filter operates on any type of data set. Its output is polygonal. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array1" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <InputArrayDomain name="input_array2" attribute_type="point"
                            number_of_components="3" optional="1"/>
          <Documentation>
            Set the input to the Glyph filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
          <ArrayListDomain name="array_list" attribute_type="Scalars" 
               input_domain_name="input_array1">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            Select the scalar array on which to operate.
          </Documentation>
     </StringVectorProperty>

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Vectors">
          <ArrayListDomain name="array_list" attribute_type="Vectors"
               input_domain_name="input_array2">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            Select the vector array on which to operate.
          </Documentation>
     </StringVectorProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Glyph Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="glyph_sources" />
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="sources" name="SphereSource" />
              <Proxy group="sources" name="ConeSource" />
              <Proxy group="sources" name="CylinderSource" />
           </ProxyListDomain>
           <Documentation>
             Select the type of glyph to use.
           </Documentation>
      </InputProperty>

     <IntVectorProperty 
        label="Orient"
        name="SetOrient" 
        command="SetOrient" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Choose whether to orient the glyphs based on the selected vector array.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        label="Scale Mode"
        name="SetScaleMode" 
        command="SetScaleMode" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="scalar"/>
         <Entry value="1" text="vector"/>
         <Entry value="2" text="vector_components"/>
         <Entry value="3" text="off"/>
       </EnumerationDomain>
       <Documentation>
         Choose whether/how to scale the glyphs.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="SetScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.1">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <ArrayRangeDomain name="scalar_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputScalars" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
       <ArrayRangeDomain name="vector_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputVectors" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
       <Documentation>
         This multiplier will be used to scale the glyphs before adding them to the output.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfPoints" 
        command="SetMaximumNumberOfPoints" 
        number_of_elements="1"
        default_values="5000"
        label="Maximum Number of Points">
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         Set the maximum number of glyphs to produce.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseMaskPoints" 
        command="SetUseMaskPoints" 
        number_of_elements="1"
        default_values="1"
        label="Mask Points"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to limit the maximum number of glyphs.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="RandomMode" 
        command="SetRandomMode" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to choose randomly which points to glyph.
       </Documentation>
     </IntVectorProperty>
   <Hints>
     <!-- Visibility Element can be used to suggest the GUI about
          visibility of this filter (or its input) on creation.
          replace_input="0" implies that the input visibility is not
            changed on creation of this filter (defaults to "1")
       -->
     <Visibility replace_input="0" />
   </Hints>
   <!-- End Glyph -->
   </SourceProxy>

   <SourceProxy name="ExtractGrid" class="vtkPVExtractVOI"
    label="Extract Grid">
    <Documentation
       long_help="Extract a subgrid from a structured grid with the option of setting subsample strides."
       short_help="Extract a subgrid or subsample.">
The Extract Grid filter returns a subgrid of a structured input data set (uniform rectilinear, curvilinear, or nonuniform rectilinear). The VOI section of the interface provides six sliders for specifying the extents of the desired output along each of the I, J, and K axes. The Sample Rate thumb wheels control whether to subsample the input grid in each dimension. Values greater than 1 result in subsampling. For example, if the Sample Rate along the I axis is 2, then every other input point will be passed to the output. If the Sample Rate in any dimension is greater than 1, then selecting the Include boundary option will pass the values on the boundary of the data set to the output even if the boundary extent is not an even multiple of the sample rate. The output data set type of this filter is the same as the input type. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
            <DataType value="vtkRectilinearGrid"/>
            <DataType value="vtkStructuredPoints"/>
            <DataType value="vtkStructuredGrid"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Extract Grid filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="VOI" 
        command="SetVOI"
        number_of_elements="6"
        default_values="0 0 0 0 0 0">
       <ExtentDomain name="extent">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ExtentDomain>
       <Documentation>
       Set the minimum/maximum values of the volume of interest (VOI). The output will have the (I,J,K) extent specified here.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="SampleRateI" 
        command="SetSampleRateI"
        animateable="1"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         Set the sampling rate in the I dimension.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="SampleRateJ" 
        command="SetSampleRateJ"
        animateable="1"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         Set the sampling rate in the J dimension.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="SampleRateK" 
        animateable="1"
        command="SetSampleRateK"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         Set the sampling rate in the K dimension.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="IncludeBoundary" 
        command="SetIncludeBoundary" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to always include the boundary of the grid in the output.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End ExtractGrid -->
   </SourceProxy>

   <SourceProxy name="DataAnalysis" class="vtkDataAnalysisFilter"
    label="Data Analysis (Pick/Probe)">
    <Documentation
       long_help="Sample point data at a point or along a line or by point id. Select cell at a point or by cell id. Data can be plotted on an XY plot."
       short_help="Pick a cell or point.">
    The Data Analysis filter provides the ability to query either cell or point data in a given data set. The data may be plotted as an plot. If the "Query Method" is "Point", the filter outputs the interpolated point data at the selected point. If the "Query Method" is "Cell", the filter outputs the cell data at the closest cell to the choosen point. If the "Query Method" is "Line", the filter interpolates the point data at the sample points on the line. If the "Query Method" is "Cell Id", the filter outputs the cell data for the cell with the given Id. If the "Query Method" is "Point Id", the filter outpus the point data for the point with the given Id. The data can be plotted on an XY plot. Additionally, if the input supports multiple timesteps, this filter can be used to plot the queried data over time.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkMultiGroupDataSet"/>
          </DataTypeDomain>
          <NumberOfPartsDomain name="multi_part" multiplicity="single"/>
          <NumberOfGroupsDomain name="multi_group" multiplicity="single"/>
          <Documentation>
            Set the input to the Data Analysis (Pick/Probe) filter.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <Documentation>
             Choose the dataset to probe with.
           </Documentation>
     </InputProperty>

     <IntVectorProperty name="Mode"
        command="SetMode"
        number_of_elements="1"
        default_values="1">
        <EnumerationDomain name="enum">
          <Entry text="Probe" value="0" />
          <Entry text="Pick" value="1" />
        </EnumerationDomain>
        <Documentation>
          Choose whether to perform a pick or probe.
        </Documentation>
     </IntVectorProperty>
     <IntVectorProperty name="Id"
        command="SetId"
        number_of_elements="1"
        default_values="0">
        <IntRangeDomain name="range" min="0" />
        <Documentation>
          Set the Id of the point or cell to pick.
        </Documentation>
     </IntVectorProperty>
     <IntVectorProperty name="UseIdToPick"
        command="SetUseIdToPick"
        number_of_elements="1"
        default_values="0"
        label="Use Id to Pick">
        <BooleanDomain name="bool" />
        <Documentation>
          Select whether to pick based on a point or cell Id.
        </Documentation>
     </IntVectorProperty>
     <IntVectorProperty name="PickCell"
        command="SetPickCell"
        number_of_elements="1"
        default_values="1"
        label="Pick Cells">
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle whether to pick cells or points.
        </Documentation>
     </IntVectorProperty>
     <DoubleVectorProperty
         name="WorldPoint"
         command="SetWorldPoint"
         number_of_elements="3"
         default_values="0 0 0" >
         <Documentation>
           Pick the cell or point closest to this world point.  The 'p' key can be used to select a point under the cursor.
         </Documentation>
      </DoubleVectorProperty>
   <!-- End PickProbe -->
   </SourceProxy>

   <SourceProxy name="Probe" class="vtkPProbeFilter">
    <Documentation
       long_help="Sample data attributes at a point or along a line.  Probed lines will be displayed in a graph of the attributes."
       short_help="Sample data values at a point or along a line.">
The Probe filter samples the data set attributes of the current data set at a point or along a line. Selecting either Point or Line from the menu button in the Probe object portion of the interface displays the appropriate 3D widget and its associated user interface controls. See section 7.4 for more information about using 3D widgets.
If you are probing with a point, the values of the point-centered variables at the selected point will be listed on the Parameters tab for this filter. If you are probing with a line, the values of the point-centered variables along that line will be displayed in a 2D graph in the display area if Show XY-Plot is selected.
Probing with a point is different from using the Pick filter at a point because the Pick filter displays the values for the input point closest to the selected point. Instead the Probe filter uses interpolation to determine the value at the selected point, whether or not it lies at an input point.
The Probe filter operates on any type of data and produces polygonal output (a point or a line).
    </Documentation>
    <InputProperty
       name="Source"
       command="SetSourceConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkMultiGroupDataSet"/>
          </DataTypeDomain>
          <NumberOfPartsDomain name="multi_part" multiplicity="single"/>
          <NumberOfGroupsDomain name="multi_group" multiplicity="single"/>
          <InputArrayDomain name="input_array" attribute_type="point"/>
          <Documentation>
            Select the dataset from which to obtain probe values.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <Documentation>
             Select the dataset whose geometry will be used in determining positions to probe.
           </Documentation>
      </InputProperty>
   <!-- End Probe -->
   </SourceProxy>

   <SourceProxy name="Probe2" class="vtkPProbeFilter">
    <!-- This is same a Probe except that the Input is the data in which we are probing,
         while source is the dataset with which we are probing. The output is of the
         type of the source.
      -->
    <Documentation
       long_help="Sample data attributes at a point or along a line.  Probed lines will be displayed in a graph of the attributes."
       short_help="Sample data values at a point or along a line.">
The Probe filter samples the data set attributes of the current data set at a point or along a line. Selecting either Point or Line from the menu button in the Probe object portion of the interface displays the appropriate 3D widget and its associated user interface controls. See section 7.4 for more information about using 3D widgets.
If you are probing with a point, the values of the point-centered variables at the selected point will be listed on the Parameters tab for this filter. If you are probing with a line, the values of the point-centered variables along that line will be displayed in a 2D graph in the display area if Show XY-Plot is selected.
Probing with a point is different from using the Pick filter at a point because the Pick filter displays the values for the input point closest to the selected point. Instead the Probe filter uses interpolation to determine the value at the selected point, whether or not it lies at an input point.
The Probe filter operates on any type of data and produces polygonal output (a point or a line).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetSourceConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkMultiGroupDataSet"/>
          </DataTypeDomain>
          <NumberOfPartsDomain name="multi_part" multiplicity="single"/>
          <NumberOfGroupsDomain name="multi_group" multiplicity="single"/>
          <InputArrayDomain name="input_array" attribute_type="point"/>
          <Documentation>
            Select the dataset from which to obtain probe values.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetInputConnection"
        label="Probe Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
             <Proxy group="extended_sources" name="LineSource" />
             <Proxy group="extended_sources" name="PointSource" />
           </ProxyListDomain>
           <Documentation>
             Select the dataset whose geometry will be used in determining positions to probe.
           </Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
        <View type="XYPlot" />
      </Hints>
   <!-- End Probe2 -->
   </SourceProxy>

   <SourceProxy name="TemporalProbe" class="vtkTemporalProbeFilter">
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the temporal probe filter.
          </Documentation>
    </InputProperty>
 
    <Property
       name="AnimateInit"
       command="AnimateInit"
       is_internal="1">
    </Property>

    <DoubleVectorProperty
       name="AnimateTick"
       command="AnimateTick"
       is_internal="1"
       number_of_elements="1"
       default_values="0.0" >
          <DoubleRangeDomain name="range" min="0" max="1" />
          <Documentation>
            Specify the time value at which to probe.
          </Documentation>
    </DoubleVectorProperty>
    <Hints>
      <Visibility replace_input="0" />
    </Hints>
   <!-- End TemporalProbe -->
   </SourceProxy>

   <SourceProxy name="TemporalPick" class="vtkTemporalPickFilter">
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkUnstructuredGrid"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Temporal Pick filter.
          </Documentation>
    </InputProperty>
 
    <Property
       name="AnimateInit"
       command="AnimateInit"
       is_internal="1">
    </Property>

    <DoubleVectorProperty
       name="AnimateTick"
       command="AnimateTick"
       is_internal="1"
       number_of_elements="1"
       default_values="0.0" >
          <DoubleRangeDomain name="range" min="0" max="1" />
          <Documentation>
            Specify the time value at which to perform a pick.
          </Documentation>          
    </DoubleVectorProperty>

    <IntVectorProperty 
       name="PointOrCell" 
       command="SetPointOrCell" 
       number_of_elements="1"
       default_values="0"
       label="Point or Cell">
       <EnumerationDomain name="enum">
         <Entry value="0" text="On"/>
         <Entry value="1" text="Off"/>
       </EnumerationDomain>
       <Documentation>
         Select whether to pick a point (0) or cell (1).
       </Documentation>
    </IntVectorProperty>
    <Hints>
       <Visibility replace_input="0" />
    </Hints>
   <!-- End TemporalPick -->
   </SourceProxy>


   <SourceProxy name="StreamTracer" class="vtkDistributedStreamTracer"
    label="Stream Tracer">
    <Documentation
       long_help="Integrate streamlines in a vector field."
       short_help="Integrate streamlines in a vector field.">
The Stream Tracer filter generates streamlines in a vector field from a collection of seed points. The vector field used is selected from the Vectors menu, so the input data set is required to have point-centered vectors. The Seed portion of the interface allows you to select whether the seed points for this integration lie in a point cloud or along a line. Depending on which is selected, the appropriate 3D widget (point or line widget) is displayed along with traditional user interface controls for positioning the point cloud or line within the data set. Instructions for using the 3D widgets and the corresponding manual controls can be found in section 7.4.
The Max. Propagation entry box allows you to specify the maximum length of the streamlines. From the Max. Propagation menu, you can select the units to be either Time (the time a particle would travel with steady flow) or Length (in the data set's spatial coordinates).
The Init. Step Len. menu and entry specify the initial step size for integration. (For non-adaptive integrators, Runge-Kutta 2 and 4, the initial step size is used throughout the integration.) The menu allows you to specify the units. Time and Length have the same meaning as for Max. Propagation. Cell Length specifies the step length as a number of cells.
The Integration Direction menu determines in which direction(s) the stream trace will be generated: FORWARD, BACKWARD, or BOTH.
The Integrator Type section of the interface determines which calculation to use for integration: Runge-Kutta 2, Runge-Kutta 4, or Runge-Kutta 4-5. If Runge-Kutta 4-5 is selected, controls are displayed for specifying the minimum and maximum step length and the maximum error. The controls for specifying Min. Step Len. and Max. Step Len. are the same as those for Init. Step Len. The Runge-Kutta 4-5 integrator tries to choose the step size so that the estimated error is less than the value of the Maximum Error entry.
If the integration takes more than Max. Steps to complete, if the speed goes below Term. Speed, if Max. Propagation is reached, or if a boundary of the input data set is crossed, integration terminates.
This filter operates on any type of data set, provided it has point-centered vectors. The output is polygonal data containing polylines. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="AddInputConnection"
       clean_command="RemoveAllInputs"
       multiple_input="1">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type" composite_data_supported="1">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="3"/>
          <Documentation>
            Set the input to the Stream Tracer filter.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Seed Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="extended_sources" name="PointSource" />
              <Proxy group="extended_sources" name="LineSource" />
           </ProxyListDomain>
           <Documentation>
             Specify the seed points for generating the streamlines.
           </Documentation>
      </InputProperty>

     <StringVectorProperty 
        name="SelectInputVectors" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Vectors">
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             Choose the vector array from which to generate streamlines.
           </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
        name="NumberOfPoints"
        number_of_elements="1"
        default_values="100"
        information_only="1"/>

     <IntVectorProperty 
        name="MaximumPropagationUnit" 
        label="Max. Propagation Unit"
        command="SetMaximumPropagationUnit" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit for specifying the maximum streamline length.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumPropagation"
        label="Max. Propagation"
        command="SetMaximumPropagation"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="1.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         Specify the maximum streamline length.
       </Documentation>       
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InitialIntegrationStepUnit" 
        label="Initial Step Unit"
        command="SetInitialIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit for specifying the initial integration step.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="InitialIntegrationStep"
        label="Initial Step Length"
        command="SetInitialIntegrationStep"
        number_of_elements="1"
        default_values="0.5" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the initial integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="IntegrationDirection" 
        command="SetIntegrationDirection" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="FORWARD"/>
         <Entry value="1" text="BACKWARD"/>
         <Entry value="2" text="BOTH"/>
       </EnumerationDomain>
       <Documentation>
         Choose the integration direction.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="IntegratorType" 
        command="SetIntegratorType" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
       <Documentation>
         Choose the type of integrator to use.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumError"
        command="SetMaximumError"
        number_of_elements="1"
        default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Set the maximum error allowed in the integration. The meaning of this value depends on the integrator chosen.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MinimumIntegrationStepUnit" 
        label="Minimum Step Unit"
        command="SetMinimumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit to use for specifying the minimum integration step.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MinimumIntegrationStep"
        label="Minimum Step Length"
        command="SetMinimumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the minimum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumIntegrationStepUnit" 
        label="Maximum Step Unit"
        command="SetMaximumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit to use for specifying the maximum integration step.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumIntegrationStep"
        label="Maximum Step Length"
        command="SetMaximumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the maximum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfSteps" 
        label="Max. Steps"
        command="SetMaximumNumberOfSteps" 
        number_of_elements="1"
        default_values="2000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         Specify the maximum number of steps used in the integration.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="TerminalSpeed"
        label="Term. Speed"
        command="SetTerminalSpeed"
        number_of_elements="1"
        default_values="0.000000000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If at any point the speed is below this value, the integration is terminated.
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End StreamTracer -->
   </SourceProxy>

   <SourceProxy name="StructuredGridOutlineFilter" 
                class="vtkStructuredGridOutlineFilter"
                label="Outline (curvilinear)">
      <Documentation
         long_help="This filter generates an outline representation of the input."
         short_help="Generates an outline.">
The Outline filter generates an outline of the outside edges of the input data set. The Input menu specifies the data set for which to create an outline. This filter operates structured grid data sets and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkStructuredGrid"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the outline (curvilinear) filter.
           </Documentation>
      </InputProperty>
   <!-- End StructuredGridOutlineFilter -->
   </SourceProxy>

   <SourceProxy name="Pick" class="vtkPickFilter">
     <Documentation
        long_help="Find the cell or point closest to the input point."
        short_help="Pick cells or points.">
The Pick filter displays the underlying data nearest to a user-selected point. A point widget, with its usual controls in the display area and on the Parameters tab, is provided for choosing this point. (See section 7.4 for information about using the point widget.) Pressing the "P" key positions the point widget at the point on the data set under the current cursor position. If you select Point from the Pick Type menu, the output of the filter will be the nearest point to the point widget. If you select Cell, the output of the filter is the cell which is closest to the selected point. All the output point-centered attributes, cell-centered attributes, and original ids are displayed on the Parameters tab. Also, the selected cell will be outlined in red in the display area, and the reference ids of the points within that cell will be labeled.
The Pick filter operates on any type of data and produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs"
        multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Pick filter.
           </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="WorldPoint"
         command="SetWorldPoint"
         number_of_elements="3"
         default_values="0 0 0" >
         <Documentation>
           Pick the cell or point closest to this world point.  The 'p' key can be used to select the point under the cursor.
         </Documentation>
      </DoubleVectorProperty>

     <IntVectorProperty 
        name="PickCell" 
        command="SetPickCell" 
        number_of_elements="1"
        default_values="1"
        label="Pick Type">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Point"/>
         <Entry value="1" text="Cell"/>
       </EnumerationDomain>
       <Documentation>
         Choose whether to pick a point or a cell.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UseIdToPick" 
        command="SetUseIdToPick" 
        number_of_elements="1"
        default_values="0"
        label="Use Id to Pick">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="On"/>
       </EnumerationDomain>
       <Documentation>
         Choose whether to pick a point/cell by Id.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Id" 
        command="SetId" 
        number_of_elements="1"
        default_values="0" >
        <Documentation>
          If picking by Id, specify the point or cell Id.
        </Documentation>
     </IntVectorProperty>

   </SourceProxy>

  <SourceProxy name="GenericClip" class="vtkGenericClip">
    <Documentation
       long_help="Clip with an implicit plane, sphere or with scalars. Clipping does not reduce the dimensionality of the data set.  This output data type of this filter is always an unstructured grid."
       short_help="Clip with an implicit plane, sphere or with scalars.">
The Generic Clip filter cuts away a portion of the input data set using a plane, a sphere, a box, or a scalar value. The menu in the Clip Function portion of the interface allows the user to select which implicit function to use or whether to clip using a scalar value. Making this selection loads the appropriate user interface. For the implicit functions, the appropriate 3D widget (plane, sphere, or box) is also displayed. The use of these 3D widgets, including their user interface components, is discussed in section 7.4.
If an implicit function is selected, the clip filter returns that portion of the input data set that lies inside the function. If Scalars is selected, then the user must specify a scalar array to clip according to. The clip filter will return the portions of the data set whose value in the selected Scalars array is larger than the Clip value. Regardless of the selection from the Clip Function menu, if the Inside Out option is checked, the opposite portions of the data set will be returned.
This filter operates on all types of data sets, and it returns unstructured grid data on output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            optional="1"/>
          <Documentation>
            Set the input to the Generic Clip filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="ClipFunction" command="SetClipFunction"
        label="Clip Type">
           <ProxyGroupDomain name="groups">
               <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             Set the parameters of the clip function.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InsideOut" 
        command="SetInsideOut" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Choose which portion of the dataset should be clipped away.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Value"
        command="SetValue"
        number_of_elements="1"
        default_values="0.0" >
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayRangeDomain>         
          <DoubleRangeDomain name="range"/>
          <Documentation>
            If clipping with a scalar array, choose the clipping value.
          </Documentation>
     </DoubleVectorProperty>
   <!-- End GenericClip -->
   </SourceProxy>

   <SourceProxy name="GenericContour" class="vtkGenericContourFilter">
    <Documentation
       long_help="Generate isolines or isosurfaces using point scalars."
       short_help="Generate isolines or isosurfaces.">
The Generic Contour filter computes isolines or isosurfaces using a selected point-centered scalar array. The available scalar arrays are listed in the Scalars menu. The scalar range of the selected array will be displayed.
The interface for adding contour values is very similar to the one for selecting cut offsets (in the Cut filter). To add a single contour value, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced contours, use the controls in the Generate range of values section. Select the number of contour values to generate using the Number of Values slider. The Range slider controls the interval in which to generate the contour values. Once the number of values and range have been selected, click the Generate button. The new values will be added to the Contour Values list. To delete a value from the Contour Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list. If no values are in the Contour Values list when Accept is pressed, the current value of the New Value slider will be used.
In addition to selecting contour values, you can also select additional computations to perform. If any of Compute Normals, Compute Gradients, or Compute Scalars is selected, the appropriate computation will be performed, and a corresponding point-centered array will be added to the output.
The Generic Contour filter operates on a generic data set, but the input is required to have at least one point-centered scalar (single-component) array. The output of this filter is polygonal.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <Documentation>
            Set the input to the Generic Contour filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        set_number_command="SetNumberOfContours"
        number_of_elements="0"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayRangeDomain>
          <Documentation>
            Specify the current contour values.
          </Documentation>          
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="ComputeNormals" 
        command="SetComputeNormals" 
        number_of_elements="1"
        default_values="1" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute normals.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeGradients" 
        command="SetComputeGradients" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute gradients.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ComputeScalars" 
        command="SetComputeScalars" 
        number_of_elements="1"
        default_values="0" 
        animateable="0"> 
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute scalars.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End GenericContour -->
   </SourceProxy>

 <SourceProxy name="GenericCut" class="vtkGenericCutter">
    <Documentation
       long_help="This filter cuts a data set with a plane or sphere.  Cutting is similar to a contour.  It creates surfaces from volumes and lines from surfaces."
       short_help="Cut datasets with planes or spheres.">
The Generic Cut filter extracts the portion of the input data set that lies along the specified plane or sphere. From the Cut Function menu, you can select whether cutting will be performed with a plane or a sphere. The appropriate 3D widget (plane widget or sphere widget) will be displayed. The parameters of the cut function can be specified interactively using the 3D widget or manually using the traditional user interface controls. Instructions for using these 3D widgets and their corresponding user interfaces are found in section 7.4.
By default, the cut lies on the specified plane or sphere. Using the Cut Offset Values portion of the interface, it is also possible to cut the data set at some offset from the original cut function. The Cut Offset Values are in the spatial units of the data set. To add a single offset, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced offsets, use the controls in the Generate range of values section. Select the number of offsets to generate using the Number of Values slider. The Range slider controls the interval in which to generate the offsets. Once the number of values and range have been selected, click the Generate button. The new offsets will be added to the Offset Values list. To delete a value from the Cut Offset Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list.
The Generic Cut filter takes a generic dataset as input. Use the Input menu to choose a data set to cut. The output of this filter is polygonal data.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Generic Cut filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="CutFunction" command="SetCutFunction"
        label="Cut Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             Set the parameters to the implicit function used for cutting.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        repeat_command="1"
        set_number_command="SetNumberOfContours"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <BoundsDomain name="bounds" mode="magnitude">
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </BoundsDomain>
          <Documentation>
            Specify a list of current offset values. This can be used to create multiple cuts with different centers. Each entry represents a new cut with center shifted by the offset value.
          </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End GenericCut -->
   </SourceProxy>

  <SourceProxy name="GenericGeometryFilter" class="vtkGenericGeometryFilter">
     <Documentation
         long_help="Extract geometry from a higher-order dataset"
         short_help="Extract geometry from a higher-order dataset">
Extract geometry from a higher-order dataset.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Generic Geometry Filter.
           </Documentation>
      </InputProperty>

   <!-- End GenericGeometryFilter -->
   </SourceProxy>

 <SourceProxy name="GenericOutlineFilter" class="vtkGenericOutlineFilter"
     label="Generic Outline">
     <Documentation
       long_help="This filter generates a bounding box representation of the input."
       short_help="Generates a bounding box.">
The Generic Outline filter generates an axis-aligned bounding box for the input data set. The Input menu specifies the data set for which to create a bounding box. This filter operates on generic data sets and produces polygonal output.
     </Documentation>
      
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Generic Outline filter.
           </Documentation>
      </InputProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End  GenericOutlineFilter -->
   </SourceProxy>

 <SourceProxy name="GenericStreamTracer" class="vtkGenericStreamTracer"
    label="Generic Stream Tracer">
    <Documentation
       long_help="Integrate streamlines in a vector field."
       short_help="Integrate streamlines in a vector field.">
The Generic Stream Tracer filter generates streamlines in a vector field from a collection of seed points. The vector field used is selected from the Vectors menu, so the input data set is required to have point-centered vectors. The Seed portion of the interface allows you to select whether the seed points for this integration lie in a point cloud or along a line. Depending on which is selected, the appropriate 3D widget (point or line widget) is displayed along with traditional user interface controls for positioning the point cloud or line within the data set. Instructions for using the 3D widgets and the corresponding manual controls can be found in section 7.4.
The Max. Propagation entry box allows you to specify the maximum length of the streamlines. From the Max. Propagation menu, you can select the units to be either Time (the time a particle would travel with steady flow) or Length (in the data set's spatial coordinates).
The Init. Step Len. menu and entry specify the initial step size for integration. (For non-adaptive integrators, Runge-Kutta 2 and 4, the initial step size is used throughout the integration.) The menu allows you to specify the units. Time and Length have the same meaning as for Max. Propagation. Cell Length specifies the step length as a number of cells.
The Integration Direction menu determines in which direction(s) the stream trace will be generated: FORWARD, BACKWARD, or BOTH.
The Integrator Type section of the interface determines which calculation to use for integration: Runge-Kutta 2, Runge-Kutta 4, or Runge-Kutta 4-5. If Runge-Kutta 4-5 is selected, controls are displayed for specifying the minimum and maximum step length and the maximum error. The controls for specifying Min. Step Len. and Max. Step Len. are the same as those for Init. Step Len. The Runge-Kutta 4-5 integrator tries to choose the step size so that the estimated error is less than the value of the Maximum Error entry.
If the integration takes more than Max. Steps to complete, if the speed goes below Term. Speed, if Max. Propagation is reached, or if a boundary of the input data set is crossed, integration terminates.
This filter operates on any type of data set, provided it has point-centered vectors. The output is polygonal data containing polylines.
    </Documentation>
       
    <InputProperty
       name="Input"
       command="AddInputConnection"
       clean_command="RemoveAllInputs"
       multiple_input="1">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="3"/>
          <Documentation>
            Set the input to the Generic Stream Tracer filter.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Specify the seed points for generating the streamlines.
           </Documentation>
      </InputProperty>

     <!-- This is a hack used to bypass the fact that ParaView
          does not have special proxies for things like point sources.
          It should be removed in the future -->
     <!-- TODO: Should this be removed now? -->
     <DoubleVectorProperty
        name="Radius"
        number_of_elements="1"
        default_values="0.1"
        information_only="1">
        <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.1">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>
          Set the radius of the point cloud for setting seed points.
        </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="NumberOfPoints"
        number_of_elements="1"
        default_values="100"
        information_only="1"/>

     <IntVectorProperty 
        name="MaximumPropagationUnit" 
        command="SetMaximumPropagationUnit" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit for specifying the maximum streamline length.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumPropagation"
        command="SetMaximumPropagation"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="1.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         Specify the maximum streamline length.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="InitialIntegrationStepUnit" 
        command="SetInitialIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit for specifying the initial integration step.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="InitialIntegrationStep"
        command="SetInitialIntegrationStep"
        number_of_elements="1"
        default_values="0.5" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the initial integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="IntegrationDirection" 
        command="SetIntegrationDirection" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="FORWARD"/>
         <Entry value="1" text="BACKWARD"/>
         <Entry value="2" text="BOTH"/>
       </EnumerationDomain>
       <Documentation>
         Choose the integration direction.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="IntegratorType" 
        command="SetIntegratorType" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain>
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
       <Documentation>
         Choose the type of integrator to use.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumError"
        command="SetMaximumError"
        number_of_elements="1"
        default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Set the maximum error allowed in the integration. The meaning of this value depends on the integrator chosen.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MinimumIntegrationStepUnit" 
        command="SetMinimumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit to use for specifying the minimum integration step.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MinimumIntegrationStep"
        command="SetMinimumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the minimum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumIntegrationStepUnit" 
        command="SetMaximumIntegrationStepUnit" 
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain>
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit to use for specifying the maximum integration step.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumIntegrationStep"
        command="SetMaximumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the maximum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="MaximumNumberOfSteps" 
        command="SetMaximumNumberOfSteps" 
        number_of_elements="1"
        default_values="2000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         Specify the maximum number of steps used in the integration.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="TerminalSpeed"
        command="SetTerminalSpeed"
        number_of_elements="1"
        default_values="0.000000000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If at any point the speed is below this value, the integration is terminated.
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End GenericStreamTracer -->
   </SourceProxy>

  <SourceProxy name="GenericTessellator" class="vtkGenericDataSetTessellator"
      label="Generic Tessellator">
     <Documentation
         long_help="Tessellate a higher-order dataset"
         short_help="Tessellate a higher-order dataset">
Tessellate a higher-order dataset.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Generic Tessellator filter.
           </Documentation>
      </InputProperty>

   <!-- End GenericTessellator -->
   </SourceProxy>

   <SourceProxy name="GroupDataSets" class="vtkMultiGroupDataGroupFilter"
    label="Group Datasets">
    <Documentation
        long_help="Group data sets."
        short_help="Group multiple inputs into one collection.">
Groups multiple datasets to create a multigroup dataset
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs"
        multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="1">
             <DataType value="vtkDataObject"/>
           </DataTypeDomain>
           <Documentation>
             Select the inputs to the Group Datasets filter.
           </Documentation>
     </InputProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End GroupDataSets -->
   </SourceProxy>

   <SourceProxy name="GroupIdScalars" class="vtkMultiGroupDataGroupIdScalars"
      label="Level Scalars">
     <Documentation
        long_help="This filter uses colors to show levels of a hiearchical dataset."
        short_help="Generate point scalars from level.">
This filter uses colors to show levels of a hiearchical dataset.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiGroupDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Level Scalars filter.
           </Documentation>
     </InputProperty>
   <!-- End GroupIdScalars -->
   </SourceProxy>

    <SourceProxy name="GeometryFilter" class="vtkPVGeometryFilter">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <!-- Does this have any data type domain? -->
          <Documentation>
            Set the input to the Geoemtry Filter.
          </Documentation>
      </InputProperty>
      <IntVectorProperty
        name="UseStrips"
        command="SetUseStrips"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <BooleanDomain name="bool"/> 
        <Documentation>
          Toggle whether to generate faces containing triangle strips. This should render faster and use less memory, but no cell data is copied.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="UseOutline"
        command="SetUseOutline"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          Toggle whether to generate an outline or a surface.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="PassThroughIds"
        command="SetPassThroughCellIds"
        number_of_elements="1"
        default_values="1"
        animateable="0">
        <BooleanDomain name="bool"/> 
        <Documentation>
          If on, the output polygonal dataset will have a celldata array that holds the cell index of the original 3D cell that produced each output cell. This is useful for cell picking.
        </Documentation>
      </IntVectorProperty>
    <!-- End GeometryFilter -->
    </SourceProxy>

    <SourceProxy name="OrderedCompositeDistributor"
                 class="vtkOrderedCompositeDistributor">
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <Documentation>
          Set the input to the Ordered Composite Distributor filter.
        </Documentation>
      </InputProperty>
      <IntVectorProperty name="PassThrough"
                         command="SetPassThrough"
                         number_of_elements="1"
                         default_values="0"
                         animateable="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          Toggle whether to pass the data through without compositing.
        </Documentation>
      </IntVectorProperty>
      <ProxyProperty name="PKdTree" command="SetPKdTree">
        <ProxyGroupDomain name="groups">
          <Group name="locators"/>
        </ProxyGroupDomain>
        <Documentation>
          Set the vtkPKdTree to distribute with.
        </Documentation>
      </ProxyProperty>
      <StringVectorProperty name="OutputType"
                            command="SetOutputType"
                            number_of_elements="1">
        <Documentation>
          When not empty, the output will be converted to the given type.
        </Documentation>
      </StringVectorProperty>
    <!-- End OrderedCompositeDistributor -->
    </SourceProxy>

    <UpdateSuppressorProxy name="UpdateSuppressor" class="vtkPVUpdateSuppressor"
      executive="vtkUpdateSuppressorPipeline">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <!-- Does this have any data type domain? -->
          <Documentation>
            Set the input to the Update Suppressor filter.
          </Documentation>
      </InputProperty>
      <Property
        name="ForceUpdate"
        command="ForceUpdate"
        is_internal="1">
      </Property>
      <Property
        name="RemoveAllCaches"
        command="RemoveAllCaches"
        immediate_update="1">
      </Property>
      <IntVectorProperty
        name="CacheUpdate"
        command="CacheUpdate"
        number_of_elements="2"
        default_values="0 -1"
        is_internal="1">
        <IntRangeDomain name="range" min="0 -1" />
      </IntVectorProperty>
      <IntVectorProperty
        name="SaveCacheOnCacheUpdate"
        command="SetSaveCacheOnCacheUpdate"
        number_of_elements="1"
        is_internal="1"
        default_values="1">
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty
        name="Enabled"
        command="SetEnabled"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle whether the update suppressor is enabled.
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty
        name="UpdateTime"
        command="SetUpdateTime"
        number_of_elements="1"
        default_values="0"
        immediate_update="1"
        is_internal="1">
        <DoubleRangeDomain name="range"/>
      </DoubleVectorProperty>
    <!-- End UpdateSuppressor -->
    </UpdateSuppressorProxy>
    
    <SourceProxy name="MPIMoveData" class="vtkMPIMoveData">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <!-- Does this have any data type domain? -->
          <Documentation>
            Set the input to the MPI Move Data filter.
          </Documentation>
      </InputProperty>
      <IntVectorProperty
        name="MoveMode"
        command="SetMoveMode"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="PassThrough" />
          <Entry value="1" text="Collect" />
          <Entry value="2" text="Clone" />
        </EnumerationDomain>
        <Documentation>
          Specify how the data is to be redistributed.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="OutputDataType"
        command="SetOutputDataType"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="PolyData" />
          <Entry value="4" text="Unstructured Grid" />
        </EnumerationDomain>
        <Documentation>
          Specify the type of the dataset.
        </Documentation>
      </IntVectorProperty>
    <!-- End MPIMoveData -->
    </SourceProxy>

    <SourceProxy name="ClientServerMoveData" class="vtkClientServerMoveData">
      <InputProperty name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <Documentation>
            Set the input to the Client Server Move Data filter.
          </Documentation>
      </InputProperty>
      <IntVectorProperty
        name="OutputDataType"
        command="SetOutputDataType"
        number_of_elements="1"
        default_values="0"
        animateable="0">
      </IntVectorProperty>
    <!-- End ClientServerMoveData -->
    </SourceProxy>
        
    <SourceProxy name="ReductionFilter" class="vtkReductionFilter">
      <InputProperty name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <Documentation>
            Set the input to the Reduction filter.
          </Documentation>
      </InputProperty>
      <ProxyProperty name="PreGatherHelper"
         command="SetPreGatherHelper">
         <Documentation>
           Set the algorithm that runs on each node in parallel.
         </Documentation>
      </ProxyProperty>
      <ProxyProperty name="PostGatherHelper"
         command="SetPostGatherHelper">
         <Documentation>
           Set the algorithm that takes multiple inputs and produces a single reduced output.
         </Documentation>
      </ProxyProperty>
      <IntVectorProperty 
         name="PassThrough" 
         command="SetPassThrough" 
         number_of_elements="1"
         default_values="-1"> 
        <IntRangeDomain name="range" min="-1"/>
        <Documentation>
          If set to a non-negative value, then produce results using only the node Id specified.
        </Documentation>
     </IntVectorProperty>

    <!-- End ReductionFilter -->
    </SourceProxy>

   <SourceProxy name="ExtractLevel" class="vtkMultiGroupDataExtractGroup"
     label="Extract Group">
     <Documentation
        long_help="This filter extracts a range of groups from a multigroup dataset."
        short_help="Extract level.">
This filter extracts a range of groups from a multigroup dataset    
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiGroupDataSet"/>
           </DataTypeDomain>
           <NumberOfGroupsDomain name="multi_group" multiplicity="multiple"/>
           <Documentation>
             Set the input to the Extract Group filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="GroupRange" 
        command="SetGroupRange" 
        number_of_elements="2"
        default_values="0 0" > 
       <NumberOfGroupsDomain name="range">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
       </NumberOfGroupsDomain>
       <Documentation>
         Set the Ids of the minimum and maximum group to extract.
       </Documentation>
     </IntVectorProperty>
   <!-- End ExtractLevel -->
   </SourceProxy>

   <SourceProxy name="ExtractDataSets" 
                class="vtkMultiGroupDataExtractDataSets"
                label="Extract Datasets">
     <Documentation
        long_help="This filter extracts a list of datasets from multigroup datasets."
        short_help="Extract datasets.">
This filter extracts a list of datasets from multigroup datasets.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiGroupDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Extract Datasets filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="SelectedDataSets" 
        command="AddDataSet"
        clean_command="ClearDataSetList"
        repeat_command="1"
        number_of_elements_per_command="2">
        <Documentation>
          Choose the datasets to extract.
        </Documentation>
     </IntVectorProperty>
   <!-- End ExtractDataSets -->
   </SourceProxy>

   <ShrunkContoursProxy name="ShrunkContours" class="vtkContourFilter"
        base_proxygroup="filters" base_proxyname="Contour">
      <SubProxy>
        <Proxy name="Shrink" proxygroup="filters" proxyname="ShrinkFilter" >
        </Proxy>
        <ExposedProperties>
          <Property name="ShrinkFactor" />
        </ExposedProperties>
      </SubProxy>
   <!-- End ShrunkContours -->
   </ShrunkContoursProxy>

   
   <SourceProxy name="TemporalCache" class="vtkTemporalCacheFilter">
     <InputProperty name="Input" command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkPointSet"/>
       </DataTypeDomain>
       <Documentation>
         Set the input to the Temporal Cache filter.
       </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="UseCache" 
        command="SetUseCache" 
        number_of_elements="1"
        default_values="0" > 
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle whether this filter will use the collected cache or simply behave as a pass-through filter.
        </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="AttributeToCollect"
        command="SetAttributeToCollect"
        number_of_elements="1"
        default_values="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="PointData" />
          <Entry value="1" text="CellData" />
          <Entry value="2" text="FieldData" />
        </EnumerationDomain>
        <Documentation>
          Choose whether point, cell, or field data is collected.
        </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="CollectAttributeData"
        command="CollectAttributeData"
        number_of_elements="1"
        default_values="0">
        <Documentation>
          Set the time to collect the data attribute.
        </Documentation>
     </DoubleVectorProperty>

     <Property
        name="ClearCache"
        command="ClearCache"
        immediate_update="1">
     </Property>
   <!-- End TemporalCache -->
   </SourceProxy>
   
   <SourceProxy name="CellSelect" class="vtkExtractSelectedFrustum">
      <Documentation
        long_help="Draw a rectangle on the screen and obtain the section of data inside it." 
        short_help="Rubber band selection inside a DataSet">
Click the Start Selection button to begin. Then use the left mouse button to make a selection rectangle on the render window. The portion of the input data set that lies within the volume in space behind the selection rectangle will be returned.
      </Documentation>

     <InputProperty name="Input" command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         Set the input to the Cell Select filter.
       </Documentation>
     </InputProperty>

     <IntVectorProperty 
        name="ExactTest" 
        command="SetExactTest" 
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="On"/>
       </EnumerationDomain>
       <Documentation>
         Choose how to determine if a cell is selected. If off, a cell is selected only if all of its points are inside the selected region. If on, only a portion of a cell must be inside for it to be selected.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="PassThrough" 
        command="SetPassThrough" 
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="On"/>
       </EnumerationDomain>
       <Documentation>
         Toggle whether new arrays are generated indicating whether a cell is selected (On) or whether a new dataset is created containing only the selected cells (Off).
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="CreateFrustum"
        command="CreateFrustum"
        number_of_elements="32"
        is_internal="1"
        argument_is_array="1"
        default_values=
        "0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0
         0.0 0.0 0.0 0.0">
     </DoubleVectorProperty>

     <IntVectorProperty 
        name="ShowBounds" 
        command="SetShowBounds" 
        number_of_elements="1"
        is_internal="1"
        default_values="0">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="On"/>
       </EnumerationDomain>
     </IntVectorProperty>
     
   <!-- End CellSelect -->
   </SourceProxy>

   <SourceProxy name="TestCut" class="vtkCutter">
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Test Cut filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="CutFunction" command="SetCutFunction"
        label="Cut Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <!--
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              -->
           </ProxyListDomain>
           <Documentation>
             Set the parameters of the cut function.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds" information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End TestCut -->
   </SourceProxy>

   <SourceProxy name="ExtractHistogram" class="vtkPExtractHistogram"
                label="Histogram">
     <Documentation
        long_help="Extract a histogram from field data."
        short_help="Extract a histogram from field data.">
     </Documentation>
    
     <InputProperty name="Input" command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array">
             <RequiredProperties>
                <Property name="SelectInputArray" 
                          function="FieldDataSelection"/>
             </RequiredProperties>
          </InputArrayDomain>
          <Documentation>
            Set the input to the Histogram filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
         name="SelectInputArray" 
         command="SetInputArrayToProcess" 
         number_of_elements="5" 
         element_types="0 0 0 0 2" 
         animateable="0"> 
          <ArrayListDomain name="array_list" 
                           attribute_type="Scalars">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <FieldDataDomain name="field_list">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </FieldDataDomain>
          <Documentation>
            Choose the array from which to compute the histogram.
          </Documentation>
     </StringVectorProperty>

     <IntVectorProperty name="BinCount" 
        command="SetBinCount" 
        number_of_elements="1" 
        default_values="10">
        <IntRangeDomain name="range" min="1" max="256"/>
        <Documentation>
          Set the number of bins for the histogram.
        </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="Component" 
        command="SetComponent" 
        number_of_elements="1" 
        default_values="0" 
        animateable="0"> 
        <IntRangeDomain name="range" min="0" max="15"/>
        <Documentation>
          Choose from which array component the histogram should be computed.
        </Documentation>
     </IntVectorProperty>

     <Hints>
       <!-- View can be used to specify the preferred view for the proxy -->
       <View type="BarChart" />
     </Hints>
   <!-- End ExtractHistogram -->
   </SourceProxy>

   
   <SourceProxy name="RectilinearGridGeometryFilter" class="vtkRectilinearGridGeometryFilter">
      <Documentation
         long_help="Extracts geometry for a rectilinear grid.  Output is a polydata dataset."
         short_help="Extracts geometry for a rectilinear grid.">
         RectilinearGridGeometryFilter is a filter that extracts geometry from a rectilinear grid. By specifying appropriate i-j-k indices, it is possible to extract a point, a curve, a surface, or a "volume".  The volume is actually a (n x m x o) region of points.  The extent specification is zero-offset.  That is, the first k-plane in a 50x50x50 rectilinear grid is given by (0,49, 0,49, 0,0).
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Rectilinear Grid Geometry filter.
           </Documentation>
      </InputProperty>
         
   <!-- End RectilinearGridGeometryFilter -->
   </SourceProxy>

   <SourceProxy name="AttributeEditor" class="vtkAttributeEditor">
     <Documentation
          long_help="Select with a point or box widget the region to edit.  This output data type of this filter is always an unstructured grid."
          short_help="Select with a point or box widget the region to edit.">
The Attribute Editor filter selects a portion of the input data set using a box. The menu in the Clip Function portion of the interface allows the user to select which implicit function to use or whether to clip using a scalar value. Making this selection loads the appropriate user interface. For the implicit functions, the appropriate 3D widget is also displayed. The use of these 3D widgets, including their user interface components, is discussed in section 7.4.
If an implicit function is selected, the clip filter returns that portion of the input data set that lies inside the function.  The filter will return the portions of the data set whose value in the selected Scalars array is larger than the Clip value. Regardless of the selection from the Clip Function menu, if the Inside Out option is checked, the opposite portions of the data set will be returned.
This filter operates on all types of data sets, and it returns unstructured grid data on output. This filter is available on the toolbar.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
          <InputArrayDomain name="input_array" number_of_components="1">
          </InputArrayDomain>
          <Documentation>
            Set the input to the Attribute Editor filter.
          </Documentation>
      </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Specify the source object used when writing out data.
           </Documentation>
      </InputProperty>

     <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             Choose the scalar array.
           </Documentation>
     </StringVectorProperty> 

     <ProxyProperty name="PickFunction" command="SetPickFunction">
           <ProxyGroupDomain name="groups">
               <Group name="implicit_functions"/>
               <Group name="3d_widgets"/>
           </ProxyGroupDomain>
           <Documentation>
             Adjust the parameters of the function used for picking.
`          </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="Value"
        command="SetAttributeValue"
        number_of_elements="1"
        default_values="0.0"
        label="Attribute Value">
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>
          <Documentation>
            Choose the scalar value to select with.
          </Documentation>       
     </DoubleVectorProperty>

      <DoubleVectorProperty
         name="WorldPoint"
         command="SetWorldPoint"
         number_of_elements="3"
         default_values="0 0 0" >
         <Documentation>
           Pick the node closest to this world point. The 'p' key can be used to select a node under the cursor.
         </Documentation>
      </DoubleVectorProperty>  
   
     <IntVectorProperty 
        name="EditMode" 
        command="SetEditMode" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle whether to perform editing.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="ClearEdits" 
        command="SetClearEdits" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         When this flag is set, the next time the filter is executed, the arrays of edits will be deleted. This is meant to be used when a timestep change is about to occur.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty 
        name="UnfilteredDataset" 
        command="SetUnfilteredDataset" 
        number_of_elements="1"
        default_values="0" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         Toggle between a source view and a filter view.
       </Documentation>
     </IntVectorProperty>
   <!-- End AttributeEditor -->
   </SourceProxy>

   <SourceProxy name="CellSelect2" class="vtkCellSelect">
     <Documentation
        long_help="testing"
        short_help="testing">
        Testing.
     </Documentation>

     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Cell Select 2 filter.
           </Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
   <!-- End CellSelect2 -->
   </SourceProxy>

   <SourceProxy name="TextureMapToPlane" class="vtkTextureMapToPlane"
     label="Texture Map to Plane">
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Texture Map to Plane filter.
          </Documentation>
     </InputProperty>
   <!-- End TextureMapToPlane -->
   </SourceProxy>

   <SourceProxy name="TextureMapToSphere" class="vtkTextureMapToSphere"
     label="Texture Map to Sphere">
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Texture Map to Sphere filter.
          </Documentation>
     </InputProperty>
   <!-- End TextureMapToSphere -->
   </SourceProxy>

   <SourceProxy name="TextureMapToCylinder" class="vtkTextureMapToCylinder"
     label="Texture Map to Cylinder">
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Texture Map to Cylinder filter.
          </Documentation>
     </InputProperty>
   <!-- End TextureMapToCylinder -->
   </SourceProxy>

   <SourceProxy name="PolyLineToRectilinearGrid"
                class="vtkPolyLineToRectilinearGridFilter"
                label="Polyline to Rectilinear Grid">
      <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Polyline to Rectilinear Grid filter.
          </Documentation>
     </InputProperty>     
   </SourceProxy>

   <SourceProxy name="MinMax" class="vtkMinMax">
      <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Min Max filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty 
        name="Operation" 
        command="SetOperation" 
        number_of_elements="1"
        default_values="MIN"> 
        <StringListDomain name="operation">
          <String value="MIN"/>
          <String value="MAX"/>
          <String value="SUM"/>
        </StringListDomain>
        <Documentation>
          Select whether to perform a min, max, or sum operation on the data.
        </Documentation>
     </StringVectorProperty>
     
   </SourceProxy>
   
   </ProxyGroup>

</ServerManagerConfiguration>

